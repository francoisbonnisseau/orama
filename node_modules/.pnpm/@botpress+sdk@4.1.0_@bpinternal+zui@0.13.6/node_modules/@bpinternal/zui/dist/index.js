var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/z/z.ts
var z_exports = {};
__export(z_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseInputLazyPath: () => ParseInputLazyPath,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodRef: () => ZodRef,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  agent: () => agent,
  aimodel: () => aimodel,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  conversation: () => conversation,
  createZodEnum: () => createZodEnum,
  cuid2Regex: () => cuid2Regex,
  cuidRegex: () => cuidRegex,
  custom: () => custom,
  datasource: () => datasource,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  default: () => defaultType,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  emailRegex: () => emailRegex,
  enum: () => enumType,
  errorUtil: () => errorUtil,
  event: () => event,
  fromJsonSchema: () => fromJsonSchema,
  fromObject: () => fromObject,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intent: () => intent,
  intersection: () => intersectionType,
  ipv4Regex: () => ipv4Regex,
  ipv6Regex: () => ipv6Regex,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isEmojiRegex: () => isEmojiRegex,
  isValid: () => isValid,
  jsonSchemaToZui: () => jsonSchemaToZui,
  knowledgebase: () => knowledgebase,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  message: () => message,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectToZui: () => objectToZui,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  processCreateParams: () => processCreateParams,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  readonly: () => readonlyType,
  record: () => recordType,
  ref: () => refType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  table: () => table,
  tablerow: () => tablerow,
  transformer: () => effectsType,
  tuple: () => tupleType,
  ulidRegex: () => ulidRegex,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  user: () => user,
  util: () => util,
  uuidRegex: () => uuidRegex,
  variable: () => variable,
  void: () => voidType,
  zuiToJsonSchema: () => zuiToJsonSchema
});

// src/ui/constants.ts
var zuiKey = "x-zui";

// src/ui/hooks/useDiscriminator.ts
import { useMemo as useMemo2, useEffect as useEffect2 } from "react";

// src/ui/hooks/useFormData.tsx
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";
var FormDataContext = createContext({
  formData: void 0,
  formSchema: void 0,
  setFormData: /* @__PURE__ */ __name(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setFormData"),
  setHiddenState: /* @__PURE__ */ __name(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setHiddenState"),
  setDisabledState: /* @__PURE__ */ __name(() => {
    throw new Error("Must be within a FormDataProvider");
  }, "setDisabledState"),
  hiddenState: {},
  disabledState: {},
  validation: { formValid: null, formErrors: null }
});
var parseMaskableField = /* @__PURE__ */ __name((key, fieldSchema, data) => {
  var _a;
  const value = (_a = fieldSchema[zuiKey]) == null ? void 0 : _a[key];
  if (typeof value === "undefined") {
    return false;
  }
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    if (typeof window === "undefined") {
      console.warn("Function evaluation is not supported in server side rendering");
      return false;
    }
    const func = new Function("return " + value)();
    const result = func(data);
    switch (typeof result) {
      case "object":
      case "boolean":
        return result;
      default:
        return false;
    }
  }
  return false;
}, "parseMaskableField");
var useFormData = /* @__PURE__ */ __name((fieldSchema, path) => {
  const formContext = useContext(FormDataContext);
  if (formContext === void 0) {
    throw new Error("useFormData must be used within a FormDataProvider");
  }
  const data = useMemo(() => getPathData(formContext.formData, path), [formContext.formData, path]);
  const validation = useMemo(() => {
    var _a;
    if (formContext.validation.formValid === null) {
      return { formValid: null, formErrors: null };
    }
    if (formContext.validation.formValid === false) {
      return {
        formValid: false,
        formErrors: ((_a = formContext.validation.formErrors) == null ? void 0 : _a.filter((issue) => pathMatches(issue.path, path)).map((issue) => ({
          message: issue.message,
          code: issue.code,
          path
        }))) || null
      };
    }
    return { formValid: true, formErrors: [] };
  }, [formContext.validation.formValid, formContext.validation.formErrors, path]);
  const transformedData = formContext.dataTransform ? formContext.dataTransform(data) : data;
  const hiddenMask = useMemo(
    () => parseMaskableField("hidden", fieldSchema, transformedData),
    [fieldSchema, transformedData]
  );
  const disabledMask = useMemo(
    () => parseMaskableField("disabled", fieldSchema, transformedData),
    [fieldSchema, transformedData]
  );
  useEffect(() => {
    formContext.setHiddenState((hiddenState) => setObjectPath(hiddenState, path, hiddenMask || {}));
    formContext.setDisabledState((disabledState) => setObjectPath(disabledState, path, disabledMask || {}));
  }, [JSON.stringify({ fieldSchema, data })]);
  const { disabled, hidden } = useMemo(() => {
    const hidden2 = hiddenMask === true || getPathData(formContext.hiddenState, path);
    const disabled2 = disabledMask === true || getPathData(formContext.disabledState, path);
    return { hidden: hidden2 === true, disabled: disabled2 === true };
  }, [formContext.hiddenState, formContext.disabledState, hiddenMask, disabledMask, path]);
  const handlePropertyChange = useCallback(
    (path2, data2) => {
      formContext.setFormData((formData) => setObjectPath(formData, path2, data2));
    },
    [formContext.setFormData]
  );
  const addArrayItem = useCallback(
    (path2, data2 = void 0) => {
      const defaultData = getDefaultValues(fieldSchema.items);
      formContext.setFormData((formData) => {
        const currentData = getPathData(formData, path2) || [];
        if (data2 === void 0) {
          data2 = defaultData;
        }
        return setObjectPath(formData, path2, Array.isArray(currentData) ? [...currentData, data2] : [data2]);
      });
    },
    [formContext.setFormData]
  );
  const removeArrayItem = useCallback(
    (path2, index) => {
      formContext.setFormData((formData) => {
        const currentData = getPathData(formData, path2) || [];
        if (!Array.isArray(currentData)) {
          return formData;
        }
        currentData.splice(index, 1);
        return setObjectPath(formData, path2, currentData);
      });
    },
    [formContext.setFormData]
  );
  return __spreadValues(__spreadProps(__spreadValues({}, formContext), { data, disabled, hidden, handlePropertyChange, addArrayItem, removeArrayItem }), validation);
}, "useFormData");
function setObjectPath(obj, path, data) {
  if (path.length === 0) {
    return data;
  }
  const pathLength = path.length;
  path.reduce((current, key, index) => {
    if (index === pathLength - 1) {
      current[key] = data;
    } else {
      if (!current[key]) {
        current[key] = isNaN(Number(key)) ? {} : [];
      }
    }
    return current[key];
  }, obj != null ? obj : {});
  return __spreadValues({}, obj);
}
__name(setObjectPath, "setObjectPath");
var getDefaultValues = /* @__PURE__ */ __name((schema, optional) => {
  var _a, _b, _c, _d;
  if (Array.isArray(schema)) {
    return getDefaultValues(schema[0]);
  }
  if (schema.default) {
    return schema.default;
  }
  if (schema.nullable) {
    return null;
  }
  if (optional) {
    return void 0;
  }
  if ((_a = schema.anyOf) == null ? void 0 : _a.length) {
    return getDefaultValues(schema.anyOf[0]);
  }
  if (schema.type === "object") {
    if (schema.properties) {
      const data = {};
      Object.entries(schema.properties).map(([key, fieldSchema]) => {
        var _a2;
        data[key] = getDefaultValues(fieldSchema, !((_a2 = schema.required) == null ? void 0 : _a2.includes(key)) || isOptional(fieldSchema) || false);
      });
      return data;
    }
  }
  if (schema.type === "array") {
    if (schema.minItems && schema.minItems > 0) {
      return [getDefaultValues(schema.items)];
    }
    return [];
  }
  if (schema.type === "string") {
    if ((_b = schema.enum) == null ? void 0 : _b.length) {
      return schema.enum[0];
    }
    return "";
  }
  if (schema.type === "number") {
    if ((_c = schema.enum) == null ? void 0 : _c.length) {
      return schema.enum[0];
    }
    return 0;
  }
  if (schema.type === "boolean") {
    if ((_d = schema.enum) == null ? void 0 : _d.length) {
      return schema.enum[0];
    }
    return false;
  }
  return void 0;
}, "getDefaultValues");
var FormDataProvider = /* @__PURE__ */ __name(({
  children,
  setFormData,
  formData,
  formSchema,
  disableValidation,
  onValidation,
  dataTransform
}) => {
  const [hiddenState, setHiddenState] = useState({});
  const [disabledState, setDisabledState] = useState({});
  const transformedData = dataTransform ? dataTransform(formData) : formData;
  const validation = useMemo(() => {
    if (disableValidation) {
      return { formValid: null, formErrors: null };
    }
    if (!formSchema) {
      return { formValid: null, formErrors: null };
    }
    const validation2 = jsonSchemaToZui(formSchema).safeParse(transformedData);
    if (!validation2.success) {
      return {
        formValid: false,
        formErrors: validation2.error.issues
      };
    }
    return {
      formValid: true,
      formErrors: []
    };
  }, [JSON.stringify({ transformedData })]);
  useEffect(() => {
    if (onValidation) {
      onValidation(validation);
    }
  }, [validation]);
  return /* @__PURE__ */ React.createElement(
    FormDataContext.Provider,
    {
      value: {
        formData,
        setFormData,
        formSchema,
        validation,
        hiddenState,
        setHiddenState,
        disabledState,
        setDisabledState,
        dataTransform
      }
    },
    children
  );
}, "FormDataProvider");
function getPathData(object, path) {
  return path.reduce((prev, curr) => {
    return prev ? prev[curr] : null;
  }, object);
}
__name(getPathData, "getPathData");
function isOptional(schema) {
  var _a;
  return ((_a = schema.anyOf) == null ? void 0 : _a.some((s) => s.not && Object.keys(s.not).length === 0)) || false;
}
__name(isOptional, "isOptional");
function deepMerge(target, source) {
  const output4 = __spreadValues({}, target);
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      if (typeof source[key] === "object" && source[key] !== null && !Array.isArray(source[key])) {
        if (typeof output4[key] === "object" && output4[key] !== null && !Array.isArray(output4[key])) {
          output4[key] = deepMerge(output4[key], source[key]);
        } else {
          output4[key] = deepMerge({}, source[key]);
        }
      } else {
        output4[key] = source[key];
      }
    }
  }
  return output4;
}
__name(deepMerge, "deepMerge");

// src/ui/hooks/useDiscriminator.ts
var useDiscriminator = /* @__PURE__ */ __name((fieldSchema, path) => {
  const { handlePropertyChange, data } = useFormData(fieldSchema, path);
  const { discriminator, value, discriminatedSchema } = useMemo2(() => {
    const discriminator2 = resolveDiscriminator(fieldSchema.anyOf);
    const value2 = (discriminator2 == null ? void 0 : discriminator2.key) ? data == null ? void 0 : data[discriminator2.key] : fieldSchema.default || null;
    const discriminatedSchema2 = resolveDiscriminatedSchema((discriminator2 == null ? void 0 : discriminator2.key) || null, value2, fieldSchema.anyOf);
    return {
      discriminator: discriminator2,
      value: value2,
      discriminatedSchema: discriminatedSchema2
    };
  }, [fieldSchema.anyOf, data]);
  useEffect2(() => {
    if ((discriminator == null ? void 0 : discriminator.key) && (discriminator == null ? void 0 : discriminator.values.length) && Object.keys(data || {}).length < 1 && !fieldSchema.default) {
      handlePropertyChange(path, { [discriminator.key]: discriminator.values[0] });
    }
  }, []);
  return { discriminator, discriminatorValue: value, discriminatedSchema };
}, "useDiscriminator");
var resolveDiscriminator = /* @__PURE__ */ __name((anyOf) => {
  const output4 = anyOf == null ? void 0 : anyOf.map((schema) => {
    if (schema.type !== "object") {
      return null;
    }
    if (!schema.properties) {
      return null;
    }
    return Object.entries(schema.properties).map(([key, def]) => {
      var _a;
      if (def.type === "string" && ((_a = def.enum) == null ? void 0 : _a.length)) {
        return { key, value: def.enum[0] };
      }
      return null;
    }).filter((v) => !!v);
  }).flat().reduce(
    (acc, data) => {
      if (!data) {
        return acc;
      }
      const { key, value } = data;
      if (acc.key === null) {
        acc.key = key;
      }
      if (acc.key === key) {
        acc.values.push(value);
      }
      return acc;
    },
    { key: null, values: [] }
  );
  if ((output4 == null ? void 0 : output4.key) === null || !(output4 == null ? void 0 : output4.values.length)) {
    return null;
  }
  return output4;
}, "resolveDiscriminator");
var resolveDiscriminatedSchema = /* @__PURE__ */ __name((key, value, anyOf) => {
  var _a, _b;
  if (!(anyOf == null ? void 0 : anyOf.length) || !key || !value) {
    return null;
  }
  for (const schema of anyOf) {
    if (schema.type !== "object") {
      continue;
    }
    const discriminator = (_a = schema.properties) == null ? void 0 : _a[key];
    if ((discriminator == null ? void 0 : discriminator.type) === "string" && ((_b = discriminator.enum) == null ? void 0 : _b.length) && discriminator.enum[0] === value) {
      return __spreadProps(__spreadValues({}, schema), {
        properties: __spreadProps(__spreadValues({}, schema.properties), {
          [key]: __spreadProps(__spreadValues({}, discriminator), { [zuiKey]: { hidden: true } })
        })
      });
    }
  }
  return null;
}, "resolveDiscriminatedSchema");

// src/ui/utils.ts
var getSchemaType = /* @__PURE__ */ __name((schema) => {
  var _a;
  if ((_a = schema.anyOf) == null ? void 0 : _a.length) {
    const discriminator = resolveDiscriminator(schema.anyOf);
    return discriminator ? "discriminatedUnion" : "object";
  }
  if (schema.type === "integer") {
    return "number";
  }
  return schema.type;
}, "getSchemaType");
var resolveComponent = /* @__PURE__ */ __name((components, fieldSchema) => {
  var _a, _b, _c;
  const type = getSchemaType(fieldSchema);
  const uiDefinition = ((_a = fieldSchema[zuiKey]) == null ? void 0 : _a.displayAs) || null;
  if (!uiDefinition || !Array.isArray(uiDefinition) || uiDefinition.length < 2) {
    const defaultComponent = (_b = components == null ? void 0 : components[type]) == null ? void 0 : _b.default;
    if (!defaultComponent) {
      return null;
    }
    return {
      Component: defaultComponent,
      type,
      id: "default",
      params: {}
    };
  }
  const componentID = uiDefinition[0];
  const Component2 = ((_c = components == null ? void 0 : components[type]) == null ? void 0 : _c[componentID]) || null;
  if (!Component2) {
    console.warn(`Component ${type}.${componentID} not found`);
    return null;
  }
  const params = uiDefinition[1] || {};
  return {
    Component: Component2,
    type,
    id: componentID,
    params
  };
}, "resolveComponent");
function pathMatches(path1, path2) {
  if (path1.length !== path2.length) return false;
  return path1.every((part, index) => part === path2[index]);
}
__name(pathMatches, "pathMatches");
function formatTitle(title, separator) {
  if (!separator) separator = new RegExp("/s|-|_| ", "g");
  return decamelize(title).split(separator).map(capitalize).map(handleSpecialWords).reduce(combine);
}
__name(formatTitle, "formatTitle");
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.substring(1);
}
__name(capitalize, "capitalize");
function combine(acc, text) {
  return `${acc} ${text}`;
}
__name(combine, "combine");
function decamelize(text) {
  return text.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
}
__name(decamelize, "decamelize");
function handleSpecialWords(text, index, words) {
  const lowercaseStr = text.toLowerCase();
  const uppercaseStr = text.toUpperCase();
  for (const special of specialCase) {
    if (special.toLowerCase() === lowercaseStr) return special;
  }
  if (acronyms.includes(uppercaseStr)) return uppercaseStr;
  if (index === 0) return text;
  if (index === words.length - 1) return text;
  if (text.length >= 4) return text;
  if (prepositions.includes(lowercaseStr)) return lowercaseStr;
  if (conjunctions.includes(lowercaseStr)) return lowercaseStr;
  if (articles.includes(lowercaseStr)) return lowercaseStr;
  return text;
}
__name(handleSpecialWords, "handleSpecialWords");
var acronyms = [
  "2D",
  "3D",
  "4WD",
  "A2O",
  "API",
  "BIOS",
  "CCTV",
  "CC",
  "CCV",
  "CD",
  "CD-ROM",
  "COBOL",
  "CIA",
  "CMS",
  "CSS",
  "CSV",
  "CV",
  "DIY",
  "DVD",
  "DB",
  "DNA",
  "E3",
  "EIN",
  "ESPN",
  "FAQ",
  "FAQs",
  "FTP",
  "FPS",
  "FORTRAN",
  "FBI",
  "HTML",
  "HTTP",
  "ID",
  "IP",
  "ISO",
  "JS",
  "JSON",
  "LASER",
  "M2A",
  "M2M",
  "M2MM",
  "M2O",
  "MMORPG",
  "NAFTA",
  "NASA",
  "NDA",
  "O2M",
  "PDF",
  "PHP",
  "POP",
  "RAM",
  "RNGR",
  "ROM",
  "RPG",
  "RTFM",
  "RTS",
  "SCUBA",
  "SITCOM",
  "SKU",
  "SMTP",
  "SQL",
  "SSN",
  "SWAT",
  "TBS",
  "TTL",
  "TV",
  "TNA",
  "UI",
  "URL",
  "USB",
  "UWP",
  "VIP",
  "W3C",
  "WYSIWYG",
  "WWW",
  "WWE",
  "WWF"
];
var articles = ["a", "an", "the"];
var conjunctions = [
  "and",
  "that",
  "but",
  "or",
  "as",
  "if",
  "when",
  "than",
  "because",
  "while",
  "where",
  "after",
  "so",
  "though",
  "since",
  "until",
  "whether",
  "before",
  "although",
  "nor",
  "like",
  "once",
  "unless",
  "now",
  "except"
];
var prepositions = [
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "because of",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "besides",
  "between",
  "beyond",
  "but",
  "by",
  "concerning",
  "despite",
  "down",
  "during",
  "except",
  "excepting",
  "for",
  "from",
  "in",
  "in front of",
  "inside",
  "in spite of",
  "instead of",
  "into",
  "like",
  "near",
  "of",
  "off",
  "on",
  "onto",
  "out",
  "outside",
  "over",
  "past",
  "regarding",
  "since",
  "through",
  "throughout",
  "to",
  "toward",
  "under",
  "underneath",
  "until",
  "up",
  "upon",
  "up to",
  "with",
  "within",
  "without",
  "with regard to",
  "with respect to"
];
var specialCase = [
  "2FA",
  "3D",
  "4K",
  "5K",
  "8K",
  "AGI",
  "BI",
  "ChatGPT",
  "CTA",
  "DateTime",
  "GitHub",
  "GPT",
  "HD",
  "IBMid",
  "ID",
  "IDs",
  "iMac",
  "IMAX",
  "iOS",
  "IP",
  "iPad",
  "iPhone",
  "iPod",
  "LDAP",
  "LinkedIn",
  "LLM",
  "M2M",
  "M2O",
  "macOS",
  "McDonalds",
  "ML",
  "MySQL",
  "NLG",
  "NLP",
  "NLU",
  "O2M",
  "OpenAI",
  "PDFs",
  "PEFT",
  "pH",
  "PostgreSQL",
  "SEO",
  "TTS",
  "UHD",
  "UUID",
  "XSS",
  "YouTube"
];
function isObjectSchema(schema) {
  return schema.type === "object" && typeof schema.properties === "object" && schema.properties !== null;
}
__name(isObjectSchema, "isObjectSchema");
function isArraySchema(schema) {
  return schema.type === "array" && typeof schema.items === "object" && schema.items !== null;
}
__name(isArraySchema, "isArraySchema");

// src/transforms/common/utils.ts
function primitiveToTypscriptLiteralType(x) {
  if (typeof x === "symbol") {
    return "symbol";
  }
  if (typeof x === "bigint") {
    const str = x.toString();
    return `${str}n`;
  }
  return primitiveToTypescriptValue(x);
}
__name(primitiveToTypscriptLiteralType, "primitiveToTypscriptLiteralType");
function primitiveToTypescriptValue(x) {
  if (typeof x === "undefined") {
    return "undefined";
  }
  if (typeof x === "symbol") {
    if (x.description) {
      return `Symbol(${primitiveToTypescriptValue(x.description)})`;
    }
    return "Symbol()";
  }
  if (typeof x === "bigint") {
    const str = x.toString();
    return `BigInt(${str})`;
  }
  return JSON.stringify(x);
}
__name(primitiveToTypescriptValue, "primitiveToTypescriptValue");
function unknownToTypescriptValue(x) {
  if (typeof x === "undefined") {
    return "undefined";
  }
  return JSON.stringify(x);
}
__name(unknownToTypescriptValue, "unknownToTypescriptValue");
var toPropertyKey = /* @__PURE__ */ __name((key) => {
  if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key)) {
    return key;
  }
  return primitiveToTypescriptValue(key);
}, "toPropertyKey");
var capitalize2 = /* @__PURE__ */ __name((s) => s.charAt(0).toUpperCase() + s.slice(1), "capitalize");
var toTypeArgumentName = /* @__PURE__ */ __name((name) => {
  const nonAlphaNumeric = /[^a-zA-Z0-9_]/g;
  const tokens = name.split(nonAlphaNumeric).map(capitalize2).filter((t) => !!t);
  return tokens.join("");
}, "toTypeArgumentName");
var getMultilineComment = /* @__PURE__ */ __name((description) => {
  const descLines = (description != null ? description : "").split("\n").filter((l) => l.trim().length > 0);
  return descLines.length === 0 ? "" : descLines.length === 1 ? `/** ${descLines[0]} */` : `/**
 * ${descLines.join("\n * ")}
 */`;
}, "getMultilineComment");

// src/transforms/common/errors.ts
var errors_exports = {};
__export(errors_exports, {
  JsonSchemaToZuiError: () => JsonSchemaToZuiError,
  ObjectToZuiError: () => ObjectToZuiError,
  UnrepresentableGenericError: () => UnrepresentableGenericError,
  UnsupportedZuiToJsonSchemaError: () => UnsupportedZuiToJsonSchemaError,
  UnsupportedZuiToTypescriptSchemaError: () => UnsupportedZuiToTypescriptSchemaError,
  UnsupportedZuiToTypescriptTypeError: () => UnsupportedZuiToTypescriptTypeError,
  UntitledDeclarationError: () => UntitledDeclarationError,
  ZuiToJsonSchemaError: () => ZuiToJsonSchemaError,
  ZuiToTypescriptSchemaError: () => ZuiToTypescriptSchemaError,
  ZuiToTypescriptTypeError: () => ZuiToTypescriptTypeError,
  ZuiTransformError: () => ZuiTransformError
});
var _ZuiTransformError = class _ZuiTransformError extends Error {
  constructor(transform, message2) {
    super(message2);
    this.transform = transform;
  }
};
__name(_ZuiTransformError, "ZuiTransformError");
var ZuiTransformError = _ZuiTransformError;
var _JsonSchemaToZuiError = class _JsonSchemaToZuiError extends ZuiTransformError {
  constructor(message2) {
    super("json-schema-to-zui", message2);
  }
};
__name(_JsonSchemaToZuiError, "JsonSchemaToZuiError");
var JsonSchemaToZuiError = _JsonSchemaToZuiError;
var _ObjectToZuiError = class _ObjectToZuiError extends ZuiTransformError {
  constructor(message2) {
    super("object-to-zui", message2);
  }
};
__name(_ObjectToZuiError, "ObjectToZuiError");
var ObjectToZuiError = _ObjectToZuiError;
var _ZuiToJsonSchemaError = class _ZuiToJsonSchemaError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-json-schema", message2);
  }
};
__name(_ZuiToJsonSchemaError, "ZuiToJsonSchemaError");
var ZuiToJsonSchemaError = _ZuiToJsonSchemaError;
var _UnsupportedZuiToJsonSchemaError = class _UnsupportedZuiToJsonSchemaError extends ZuiToJsonSchemaError {
  constructor(type) {
    super(`Zod type ${type} cannot be transformed to JSON Schema.`);
  }
};
__name(_UnsupportedZuiToJsonSchemaError, "UnsupportedZuiToJsonSchemaError");
var UnsupportedZuiToJsonSchemaError = _UnsupportedZuiToJsonSchemaError;
var _ZuiToTypescriptSchemaError = class _ZuiToTypescriptSchemaError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-typescript-schema", message2);
  }
};
__name(_ZuiToTypescriptSchemaError, "ZuiToTypescriptSchemaError");
var ZuiToTypescriptSchemaError = _ZuiToTypescriptSchemaError;
var _UnsupportedZuiToTypescriptSchemaError = class _UnsupportedZuiToTypescriptSchemaError extends ZuiToTypescriptSchemaError {
  constructor(type) {
    super(`Zod type ${type} cannot be transformed to TypeScript schema.`);
  }
};
__name(_UnsupportedZuiToTypescriptSchemaError, "UnsupportedZuiToTypescriptSchemaError");
var UnsupportedZuiToTypescriptSchemaError = _UnsupportedZuiToTypescriptSchemaError;
var _ZuiToTypescriptTypeError = class _ZuiToTypescriptTypeError extends ZuiTransformError {
  constructor(message2) {
    super("zui-to-typescript-type", message2);
  }
};
__name(_ZuiToTypescriptTypeError, "ZuiToTypescriptTypeError");
var ZuiToTypescriptTypeError = _ZuiToTypescriptTypeError;
var _UnsupportedZuiToTypescriptTypeError = class _UnsupportedZuiToTypescriptTypeError extends ZuiToTypescriptTypeError {
  constructor(type) {
    super(`Zod type ${type} cannot be transformed to TypeScript type.`);
  }
};
__name(_UnsupportedZuiToTypescriptTypeError, "UnsupportedZuiToTypescriptTypeError");
var UnsupportedZuiToTypescriptTypeError = _UnsupportedZuiToTypescriptTypeError;
var _UntitledDeclarationError = class _UntitledDeclarationError extends ZuiToTypescriptTypeError {
  constructor() {
    super("Schema must have a title to be transformed to a TypeScript type with a declaration.");
  }
};
__name(_UntitledDeclarationError, "UntitledDeclarationError");
var UntitledDeclarationError = _UntitledDeclarationError;
var _UnrepresentableGenericError = class _UnrepresentableGenericError extends ZuiToTypescriptTypeError {
  constructor() {
    super(`${"ZodRef" /* ZodRef */} can only be transformed to a TypeScript type with a "type" declaration.`);
  }
};
__name(_UnrepresentableGenericError, "UnrepresentableGenericError");
var UnrepresentableGenericError = _UnrepresentableGenericError;

// src/transforms/zui-to-typescript-type/index.ts
var Primitives = [
  "string",
  "number",
  "boolean",
  "unknown",
  "void",
  "any",
  "null",
  "undefined",
  "never",
  "bigint",
  "symbol",
  "object"
];
var isPrimitive = /* @__PURE__ */ __name((type) => Primitives.includes(type), "isPrimitive");
var isArrayOfPrimitives = /* @__PURE__ */ __name((type) => Primitives.map((p) => `${p}[]`).includes(type), "isArrayOfPrimitives");
var stripSpaces = /* @__PURE__ */ __name((typings) => typings.replace(/ +/g, " ").trim(), "stripSpaces");
var _KeyValue = class _KeyValue {
  constructor(key, value, optional = false) {
    this.key = key;
    this.value = value;
    this.optional = optional;
  }
};
__name(_KeyValue, "KeyValue");
var KeyValue = _KeyValue;
var _FnParameters = class _FnParameters {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnParameters, "FnParameters");
var FnParameters = _FnParameters;
var _FnReturn = class _FnReturn {
  constructor(schema) {
    this.schema = schema;
  }
};
__name(_FnReturn, "FnReturn");
var FnReturn = _FnReturn;
var _Declaration = class _Declaration {
  constructor(props) {
    this.props = props;
  }
};
__name(_Declaration, "Declaration");
var Declaration = _Declaration;
function toTypescript(schema, options = {}) {
  const wrappedSchema = getDeclarationProps(schema, options);
  let dts = sUnwrapZod(wrappedSchema, {});
  if (options.formatter) {
    dts = options.formatter(dts);
  }
  return dts;
}
__name(toTypescript, "toTypescript");
function sUnwrapZod(schema, config) {
  var _a, _b, _c;
  const newConfig = __spreadProps(__spreadValues({}, config), {
    parent: schema
  });
  if (schema === null) {
    return "";
  }
  if (schema instanceof Declaration) {
    return unwrapDeclaration(schema, newConfig);
  }
  if (schema instanceof KeyValue) {
    if (schema.value instanceof z_default.ZodOptional) {
      let innerType = schema.value._def.innerType;
      if (innerType instanceof z_default.Schema && !innerType.description && schema.value.description) {
        innerType = innerType == null ? void 0 : innerType.describe(schema.value.description);
      }
      return sUnwrapZod(new KeyValue(schema.key, innerType, true), newConfig);
    }
    const description = getMultilineComment(schema.value._def.description);
    const delimiter = (description == null ? void 0 : description.trim().length) > 0 ? "\n" : "";
    const withoutDesc = schema.value.describe("");
    const isOptional2 = schema.optional || schema.value.isOptional();
    const optionalModifier = isOptional2 ? "?" : "";
    return `${delimiter}${description}${delimiter}${schema.key}${optionalModifier}: ${sUnwrapZod(withoutDesc, newConfig)}${delimiter}`;
  }
  if (schema instanceof FnParameters) {
    if (schema.schema instanceof z_default.ZodTuple) {
      let args = "";
      for (let i = 0; i < schema.schema.items.length; i++) {
        const argName = (_c = (_b = (_a = schema.schema.items[i]) == null ? void 0 : _a.ui) == null ? void 0 : _b.title) != null ? _c : `arg${i}`;
        const item = schema.schema.items[i];
        args += `${sUnwrapZod(new KeyValue(toPropertyKey(argName), item), newConfig)}${i < schema.schema.items.length - 1 ? ", " : ""} `;
      }
      return args;
    }
    const typings = sUnwrapZod(schema.schema, newConfig);
    const startsWithPairs = typings.startsWith("{") && typings.endsWith("}") || typings.startsWith("[") && typings.endsWith("]") || typings.startsWith("(") && typings.endsWith(")") || typings.startsWith("Array<") && typings.endsWith(">") || typings.startsWith("Record<") && typings.endsWith(">") || isArrayOfPrimitives(typings);
    if (startsWithPairs) {
      return `args: ${typings}`;
    } else {
      return typings;
    }
  }
  if (schema instanceof FnReturn) {
    if (schema.schema instanceof z_default.ZodOptional) {
      return `${sUnwrapZod(schema.schema.unwrap(), newConfig)} | undefined`;
    }
    return sUnwrapZod(schema.schema, newConfig);
  }
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `${getMultilineComment(def.description)} string`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `${getMultilineComment(def.description)} number`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `${getMultilineComment(schema._def.description)} boolean`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `${getMultilineComment(def.description)} Date`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `${getMultilineComment(def.description)} undefined`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `${getMultilineComment(def.description)} null`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `${getMultilineComment(def.description)} any`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `${getMultilineComment(def.description)} unknown`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `${getMultilineComment(def.description)} never`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `${getMultilineComment(def.description)} void`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      const item = sUnwrapZod(def.type, newConfig);
      if (isPrimitive(item)) {
        return `${item}[]`;
      }
      return `Array<${item}>`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = Object.entries(def.shape()).map(([key, value2]) => {
        return sUnwrapZod(new KeyValue(toPropertyKey(key), value2), newConfig);
      });
      return `{ ${props.join("; ")} }`;
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(def.description)}
${options.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map((option) => {
        return sUnwrapZod(option, newConfig);
      });
      return `${getMultilineComment(schema._def.description)}
${opts.join(" | ")}`;
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      return `${sUnwrapZod(def.left, newConfig)} & ${sUnwrapZod(def.right, newConfig)}`;
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      if (def.items.length === 0) {
        return "";
      }
      const items = def.items.map((i) => sUnwrapZod(i, newConfig));
      return `[${items.join(", ")}]`;
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod(def.keyType, newConfig);
      const valueType = sUnwrapZod(def.valueType, newConfig);
      return `${getMultilineComment(def.description)} { [key: ${keyType}]: ${valueType} }`;
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      return `Map<${sUnwrapZod(def.keyType, newConfig)}, ${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `Set<${sUnwrapZod(def.valueType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const input4 = sUnwrapZod(new FnParameters(def.args), newConfig);
      const output4 = sUnwrapZod(new FnReturn(def.returns), newConfig);
      return `${getMultilineComment(def.description)}
(${input4}) => ${output4}`;
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return sUnwrapZod(def.getter(), newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      const value = primitiveToTypscriptLiteralType(def.value);
      return `${getMultilineComment(def.description)}
${value}`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(primitiveToTypescriptValue);
      return values.join(" | ");
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      return sUnwrapZod(def.schema, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new UnsupportedZuiToTypescriptTypeError(z_default.ZodFirstPartyTypeKind.ZodNativeEnum);
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `${sUnwrapZod(def.innerType, newConfig)} | undefined`;
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `${sUnwrapZod(def.innerType, newConfig)} | null`;
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      return sUnwrapZod(def.innerType, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `Promise<${sUnwrapZod(def.type, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      return sUnwrapZod(def.type, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      return sUnwrapZod(def.in, newConfig);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      return `${getMultilineComment(def.description)} symbol`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `Readonly<${sUnwrapZod(def.innerType, newConfig)}>`;
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      return toTypeArgumentName(def.uri);
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod, "sUnwrapZod");
var unwrapDeclaration = /* @__PURE__ */ __name((declaration, options) => {
  if (declaration.props.type === "none") {
    return sUnwrapZod(declaration.props.schema, options);
  }
  const description = getMultilineComment(declaration.props.schema.description);
  const withoutDesc = declaration.props.schema.describe("");
  const typings = sUnwrapZod(withoutDesc, options);
  if (declaration.props.type === "variable") {
    return stripSpaces(`${description}declare const ${declaration.props.identifier}: ${typings};`);
  }
  const generics = declaration.props.args.length > 0 ? `<${declaration.props.args.map(toTypeArgumentName).join(", ")}>` : "";
  return stripSpaces(`${description}type ${declaration.props.identifier}${generics} = ${typings};`);
}, "unwrapDeclaration");
var getDeclarationType = /* @__PURE__ */ __name((options) => {
  if (!options.declaration) {
    return "none";
  }
  if (options.declaration === true) {
    return "variable";
  }
  return options.declaration;
}, "getDeclarationType");
var getDeclarationProps = /* @__PURE__ */ __name((schema, options) => {
  const declarationType = getDeclarationType(options);
  const args = schema.getReferences();
  if (declarationType === "none") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError();
    }
    return new Declaration({ type: "none", schema });
  }
  const title = "title" in schema.ui ? schema.ui.title : null;
  if (!title) {
    throw new UntitledDeclarationError();
  }
  if (declarationType === "variable") {
    if (args.length > 0) {
      throw new UnrepresentableGenericError();
    }
    return new Declaration({ type: "variable", identifier: title, schema });
  }
  return new Declaration({ type: "type", identifier: title, schema, args });
}, "getDeclarationProps");

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
__name(getRawTag, "getRawTag");
var getRawTag_default = getRawTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
__name(objectToString, "objectToString");
var objectToString_default = objectToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
__name(baseGetTag, "baseGetTag");
var baseGetTag_default = baseGetTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
__name(isObjectLike, "isObjectLike");
var isObjectLike_default = isObjectLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
__name(isSymbol, "isSymbol");
var isSymbol_default = isSymbol;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
__name(arrayMap, "arrayMap");
var arrayMap_default = arrayMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
var baseToString_default = baseToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
__name(isObject, "isObject");
var isObject_default = isObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
__name(identity, "identity");
var identity_default = identity;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
__name(isFunction, "isFunction");
var isFunction_default = isFunction;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
__name(isMasked, "isMasked");
var isMasked_default = isMasked;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
__name(toSource, "toSource");
var toSource_default = toSource;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
__name(baseIsNative, "baseIsNative");
var baseIsNative_default = baseIsNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
__name(getValue, "getValue");
var getValue_default = getValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
__name(getNative, "getNative");
var getNative_default = getNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
__name(isIndex, "isIndex");
var isIndex_default = isIndex;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
__name(baseAssignValue, "baseAssignValue");
var baseAssignValue_default = baseAssignValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
__name(eq, "eq");
var eq_default = eq;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
__name(isLength, "isLength");
var isLength_default = isLength;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
__name(isArrayLike, "isArrayLike");
var isArrayLike_default = isArrayLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto4;
  return value === proto;
}
__name(isPrototype, "isPrototype");
var isPrototype_default = isPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
__name(baseTimes, "baseTimes");
var baseTimes_default = baseTimes;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
__name(baseIsArguments, "baseIsArguments");
var baseIsArguments_default = baseIsArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto5 = Object.prototype;
var hasOwnProperty3 = objectProto5.hasOwnProperty;
var propertyIsEnumerable = objectProto5.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
__name(stubFalse, "stubFalse");
var stubFalse_default = stubFalse;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
__name(baseIsTypedArray, "baseIsTypedArray");
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
__name(baseUnary, "baseUnary");
var baseUnary_default = baseUnary;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
__name(arrayLikeKeys, "arrayLikeKeys");
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
__name(overArg, "overArg");
var overArg_default = overArg;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty5.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
__name(baseKeys, "baseKeys");
var baseKeys_default = baseKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
__name(keys, "keys");
var keys_default = keys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
__name(isKey, "isKey");
var isKey_default = isKey;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
__name(hashClear, "hashClear");
var hashClear_default = hashClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
__name(hashDelete, "hashDelete");
var hashDelete_default = hashDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty6.call(data, key) ? data[key] : void 0;
}
__name(hashGet, "hashGet");
var hashGet_default = hashGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty7.call(data, key);
}
__name(hashHas, "hashHas");
var hashHas_default = hashHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
__name(hashSet, "hashSet");
var hashSet_default = hashSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(Hash, "Hash");
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
__name(listCacheClear, "listCacheClear");
var listCacheClear_default = listCacheClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
__name(assocIndexOf, "assocIndexOf");
var assocIndexOf_default = assocIndexOf;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
__name(listCacheDelete, "listCacheDelete");
var listCacheDelete_default = listCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
__name(listCacheGet, "listCacheGet");
var listCacheGet_default = listCacheGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
__name(listCacheHas, "listCacheHas");
var listCacheHas_default = listCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
__name(listCacheSet, "listCacheSet");
var listCacheSet_default = listCacheSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(ListCache, "ListCache");
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
__name(mapCacheClear, "mapCacheClear");
var mapCacheClear_default = mapCacheClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
__name(isKeyable, "isKeyable");
var isKeyable_default = isKeyable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
__name(getMapData, "getMapData");
var getMapData_default = getMapData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
__name(mapCacheDelete, "mapCacheDelete");
var mapCacheDelete_default = mapCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
__name(mapCacheGet, "mapCacheGet");
var mapCacheGet_default = mapCacheGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
__name(mapCacheHas, "mapCacheHas");
var mapCacheHas_default = mapCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
__name(mapCacheSet, "mapCacheSet");
var mapCacheSet_default = mapCacheSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
__name(MapCache, "MapCache");
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = /* @__PURE__ */ __name(function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  }, "memoized");
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
__name(memoize, "memoize");
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
__name(memoizeCapped, "memoizeCapped");
var memoizeCapped_default = memoizeCapped;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
__name(toString, "toString");
var toString_default = toString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
__name(castPath, "castPath");
var castPath_default = castPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
__name(toKey, "toKey");
var toKey_default = toKey;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
__name(baseGet, "baseGet");
var baseGet_default = baseGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
__name(get, "get");
var get_default = get;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
__name(arrayPush, "arrayPush");
var arrayPush_default = arrayPush;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
__name(stackClear, "stackClear");
var stackClear_default = stackClear;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
__name(stackDelete, "stackDelete");
var stackDelete_default = stackDelete;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
__name(stackGet, "stackGet");
var stackGet_default = stackGet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
__name(stackHas, "stackHas");
var stackHas_default = stackHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
__name(stackSet, "stackSet");
var stackSet_default = stackSet;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
__name(Stack, "Stack");
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
__name(arrayFilter, "arrayFilter");
var arrayFilter_default = arrayFilter;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
__name(stubArray, "stubArray");
var stubArray_default = stubArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getSymbols.js
var objectProto10 = Object.prototype;
var propertyIsEnumerable2 = objectProto10.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
__name(baseGetAllKeys, "baseGetAllKeys");
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
__name(getAllKeys, "getAllKeys");
var getAllKeys_default = getAllKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = /* @__PURE__ */ __name(function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  }, "getTag");
}
var getTag_default = getTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
__name(setCacheAdd, "setCacheAdd");
var setCacheAdd_default = setCacheAdd;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
__name(setCacheHas, "setCacheHas");
var setCacheHas_default = setCacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
__name(SetCache, "SetCache");
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
__name(arraySome, "arraySome");
var arraySome_default = arraySome;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
__name(cacheHas, "cacheHas");
var cacheHas_default = cacheHas;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
__name(equalArrays, "equalArrays");
var equalArrays_default = equalArrays;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
__name(mapToArray, "mapToArray");
var mapToArray_default = mapToArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToArray.js
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
__name(setToArray, "setToArray");
var setToArray_default = setToArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
__name(equalByTag, "equalByTag");
var equalByTag_default = equalByTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto11 = Object.prototype;
var hasOwnProperty8 = objectProto11.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty8.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
__name(equalObjects, "equalObjects");
var equalObjects_default = equalObjects;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto12 = Object.prototype;
var hasOwnProperty9 = objectProto12.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag3 : objTag;
  othTag = othTag == argsTag3 ? objectTag3 : othTag;
  var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty9.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty9.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
__name(baseIsEqualDeep, "baseIsEqualDeep");
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
__name(baseIsEqual, "baseIsEqual");
var baseIsEqual_default = baseIsEqual;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
__name(baseIsMatch, "baseIsMatch");
var baseIsMatch_default = baseIsMatch;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
__name(isStrictComparable, "isStrictComparable");
var isStrictComparable_default = isStrictComparable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
__name(getMatchData, "getMatchData");
var getMatchData_default = getMatchData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
__name(matchesStrictComparable, "matchesStrictComparable");
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
__name(baseMatches, "baseMatches");
var baseMatches_default = baseMatches;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
__name(baseHasIn, "baseHasIn");
var baseHasIn_default = baseHasIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
__name(hasPath, "hasPath");
var hasPath_default = hasPath;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
__name(hasIn, "hasIn");
var hasIn_default = hasIn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
__name(baseMatchesProperty, "baseMatchesProperty");
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
__name(baseProperty, "baseProperty");
var baseProperty_default = baseProperty;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
__name(basePropertyDeep, "basePropertyDeep");
var basePropertyDeep_default = basePropertyDeep;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
__name(property, "property");
var property_default = property;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
__name(baseIteratee, "baseIteratee");
var baseIteratee_default = baseIteratee;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
__name(createBaseFor, "createBaseFor");
var createBaseFor_default = createBaseFor;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
__name(baseForOwn, "baseForOwn");
var baseForOwn_default = baseForOwn;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
__name(isEqual, "isEqual");
var isEqual_default = isEqual;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee_default(iteratee, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result, key, iteratee(value, key, object2));
  });
  return result;
}
__name(mapValues, "mapValues");
var mapValues_default = mapValues;

// src/transforms/zui-to-typescript-schema/index.ts
function toTypescriptSchema(schema) {
  let wrappedSchema = schema;
  let dts = sUnwrapZod2(wrappedSchema);
  return dts;
}
__name(toTypescriptSchema, "toTypescriptSchema");
function sUnwrapZod2(schema) {
  const schemaTyped = schema;
  const def = schemaTyped._def;
  switch (def.typeName) {
    case z_default.ZodFirstPartyTypeKind.ZodString:
      return `${getMultilineComment(def.description)}z.string()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNumber:
      return `${getMultilineComment(def.description)}z.number()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNaN:
      return `${getMultilineComment(def.description)}z.nan()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBigInt:
      return `${getMultilineComment(def.description)}z.bigint()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBoolean:
      return `${getMultilineComment(schema._def.description)}z.boolean()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDate:
      return `${getMultilineComment(def.description)}z.date()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUndefined:
      return `${getMultilineComment(def.description)}z.undefined()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNull:
      return `${getMultilineComment(def.description)}z.null()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodAny:
      return `${getMultilineComment(def.description)}z.any()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnknown:
      return `${getMultilineComment(def.description)}z.unknown()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNever:
      return `${getMultilineComment(def.description)}z.never()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodVoid:
      return `${getMultilineComment(def.description)}z.void()`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodArray:
      return `z.array(${sUnwrapZod2(def.type)})`;
    case z_default.ZodFirstPartyTypeKind.ZodObject:
      const props = mapValues_default(def.shape(), (value2) => {
        if (value2 instanceof z_default.Schema) {
          return sUnwrapZod2(value2);
        }
        return `z.any()`;
      });
      return [
        //
        `${getMultilineComment(def.description)}z.object({`,
        ...Object.entries(props).map(([key, value2]) => `  ${key}: ${value2},`),
        `})`
      ].join("\n").trim();
    case z_default.ZodFirstPartyTypeKind.ZodUnion:
      const options = def.options.map(sUnwrapZod2);
      return `${getMultilineComment(def.description)}z.union([${options.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      const opts = def.options.map(sUnwrapZod2);
      const discriminator = primitiveToTypescriptValue(def.discriminator);
      return `${getMultilineComment(def.description)}z.discriminatedUnion(${discriminator}, [${opts.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodIntersection:
      const left = sUnwrapZod2(def.left);
      const right = sUnwrapZod2(def.right);
      return `${getMultilineComment(def.description)}z.intersection(${left}, ${right})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodTuple:
      const items = def.items.map(sUnwrapZod2);
      return `${getMultilineComment(def.description)}z.tuple([${items.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRecord:
      const keyType = sUnwrapZod2(def.keyType);
      const valueType = sUnwrapZod2(def.valueType);
      return `${getMultilineComment(def.description)}z.record(${keyType}, ${valueType})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodMap:
      const mapKeyType = sUnwrapZod2(def.keyType);
      const mapValueType = sUnwrapZod2(def.valueType);
      return `${getMultilineComment(def.description)}z.map(${mapKeyType}, ${mapValueType})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodSet:
      return `${getMultilineComment(def.description)}z.set(${sUnwrapZod2(def.valueType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodFunction:
      const args = def.args.items.map(sUnwrapZod2);
      const argsString = args.length ? `.args(${args.join(", ")})` : "";
      const returns = sUnwrapZod2(def.returns);
      return `${getMultilineComment(def.description)}z.function()${argsString}.returns(${returns})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLazy:
      return `${getMultilineComment(def.description)}z.lazy(() => ${sUnwrapZod2(def.getter())})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodLiteral:
      const value = primitiveToTypescriptValue(def.value);
      return `${getMultilineComment(def.description)}z.literal(${value})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEnum:
      const values = def.values.map(primitiveToTypescriptValue);
      return `${getMultilineComment(def.description)}z.enum([${values.join(", ")}])`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodEffects:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodEffects);
    case z_default.ZodFirstPartyTypeKind.ZodNativeEnum:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodNativeEnum);
    case z_default.ZodFirstPartyTypeKind.ZodOptional:
      return `${getMultilineComment(def.description)}z.optional(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodNullable:
      return `${getMultilineComment(def.description)}z.nullable(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodDefault:
      const defaultValue = unknownToTypescriptValue(def.defaultValue());
      return `${getMultilineComment(def.description)}${sUnwrapZod2(def.innerType)}.default(${defaultValue})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodCatch:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodCatch);
    case z_default.ZodFirstPartyTypeKind.ZodPromise:
      return `${getMultilineComment(def.description)}z.promise(${sUnwrapZod2(def.type)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodBranded:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodBranded);
    case z_default.ZodFirstPartyTypeKind.ZodPipeline:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodPipeline);
    case z_default.ZodFirstPartyTypeKind.ZodSymbol:
      throw new UnsupportedZuiToTypescriptSchemaError(z_default.ZodFirstPartyTypeKind.ZodSymbol);
    case z_default.ZodFirstPartyTypeKind.ZodReadonly:
      return `${getMultilineComment(def.description)}z.readonly(${sUnwrapZod2(def.innerType)})`.trim();
    case z_default.ZodFirstPartyTypeKind.ZodRef:
      const uri = primitiveToTypescriptValue(def.uri);
      return `${getMultilineComment(def.description)}z.ref(${uri})`.trim();
    default:
      util.assertNever(def);
  }
}
__name(sUnwrapZod2, "sUnwrapZod");

// src/z/types/basetype/index.ts
var _ParseInputLazyPath = class _ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(_ParseInputLazyPath, "ParseInputLazyPath");
var ParseInputLazyPath = _ParseInputLazyPath;
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error) return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
var _ZodType = class _ZodType {
  constructor(def) {
    /** Alias of safeParseAsync */
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  /** deeply replace all references in the schema */
  dereference(_defs) {
    return this;
  }
  /** deeply scans the schema to check if it contains references */
  getReferences() {
    return [];
  }
  _getType(input4) {
    return getParsedType(input4.data);
  }
  _getOrReturnCtx(input4, ctx) {
    return ctx || {
      common: input4.parent.common,
      data: input4.data,
      parsedType: getParsedType(input4.data),
      schemaErrorMap: this._def.errorMap,
      path: input4.path,
      parent: input4.parent
    };
  }
  _processInputParams(input4) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input4.parent.common,
        data: input4.data,
        parsedType: getParsedType(input4.data),
        schemaErrorMap: this._def.errorMap,
        path: input4.path,
        parent: input4.parent
      }
    };
  }
  _parseSync(input4) {
    const result = this._parse(input4);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input4) {
    const result = this._parse(input4);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params == null ? void 0 : params.async) != null ? _a : false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success) return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue(__spreadValues({
        code: ZodIssueCode.custom
      }, getIssueProperties(val))), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      schema: this,
      typeName: "ZodEffects" /* ZodEffects */,
      effect: { type: "transform", transform }
    }));
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: "ZodDefault" /* ZodDefault */
    }));
  }
  brand() {
    return new ZodBranded(__spreadValues({
      typeName: "ZodBranded" /* ZodBranded */,
      type: this
    }, processCreateParams(this._def)));
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch(__spreadProps(__spreadValues({}, processCreateParams(this._def)), {
      innerType: this,
      catchValue: catchValueFunc,
      typeName: "ZodCatch" /* ZodCatch */
    }));
  }
  describe(description) {
    const This = this.constructor;
    return new This(__spreadProps(__spreadValues({}, this._def), {
      description
    }));
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  /** append metadata to object */
  metadata(data) {
    for (const [key, value] of Object.entries(data)) {
      this._def[zuiKey] = __spreadProps(__spreadValues({}, this._def[zuiKey]), {
        [key]: value
      });
    }
    return this;
  }
  /** get metadata of object */
  getMetadata() {
    return __spreadValues({}, this._def[zuiKey]);
  }
  /** set metadata of object */
  setMetadata(data) {
    this._def[zuiKey] = __spreadValues({}, data);
  }
  /**
   * @deprecated use `getMetadata` instead
   */
  get ui() {
    const root2 = this._getMetadataRoot();
    return __spreadValues({}, root2._def[zuiKey]);
  }
  _setZuiMeta(key, value) {
    const root2 = this._getMetadataRoot();
    root2._def[zuiKey] = __spreadProps(__spreadValues({}, root2._def[zuiKey]), {
      [key]: value
    });
  }
  _getMetadataRoot() {
    const def = this._def;
    switch (def.typeName) {
      case "ZodNullable" /* ZodNullable */:
      case "ZodDefault" /* ZodDefault */:
      case "ZodOptional" /* ZodOptional */:
      case "ZodReadonly" /* ZodReadonly */:
        return def.innerType;
      case "ZodEffects" /* ZodEffects */:
        return def.schema;
      default:
        return this;
    }
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(options) {
    var _a, _b, _c;
    (_c = (_a = this._def)[_b = zuiKey]) != null ? _c : _a[_b] = {};
    this._def[zuiKey].displayAs = [options.id, options.params];
    return this;
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(title) {
    this._setZuiMeta("title", title);
    return this;
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    this._setZuiMeta("hidden", data);
    return this;
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(value) {
    let data;
    if (value === void 0) {
      data = true;
    } else if (typeof value === "function") {
      data = value.toString();
    } else {
      data = value;
    }
    this._setZuiMeta("disabled", data);
    return this;
  }
  /**
   * Placeholder text for the field
   */
  placeholder(placeholder) {
    this._setZuiMeta("placeholder", placeholder);
    return this;
  }
  toJsonSchema(opts) {
    return zuiToJsonSchema(this, opts);
  }
  /**
   *
   * @param options generation options
   * @returns a string of the TypeScript type representing the schema
   */
  toTypescript(opts) {
    return toTypescript(this, opts);
  }
  /**
   *
   * @param options generation options
   * @returns a typescript program (a string) that would construct the given schema if executed
   */
  toTypescriptSchema() {
    return toTypescriptSchema(this);
  }
  async toTypescriptAsync(opts) {
    let result = toTypescript(this, __spreadProps(__spreadValues({}, opts), { formatter: void 0 }));
    if (opts == null ? void 0 : opts.formatter) {
      result = await opts.formatter(result);
    }
    return result;
  }
  static fromObject(obj, opts) {
    return objectToZui(obj, opts);
  }
  static fromJsonSchema(schema) {
    return jsonSchemaToZui(schema);
  }
};
__name(_ZodType, "ZodType");
var ZodType = _ZodType;

// src/z/types/defs.ts
var ZodFirstPartyTypeKind = /* @__PURE__ */ ((ZodFirstPartyTypeKind3) => {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodRef"] = "ZodRef";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
  return ZodFirstPartyTypeKind3;
})(ZodFirstPartyTypeKind || {});

// src/z/types/utils/index.ts
var util;
((util4) => {
  util4.assertEqual = /* @__PURE__ */ __name((val) => val, "assertEqual");
  function assertIs(_arg) {
  }
  util4.assertIs = assertIs;
  __name(assertIs, "assertIs");
  function assertNever(_x) {
    throw new Error("assertNever called");
  }
  util4.assertNever = assertNever;
  __name(assertNever, "assertNever");
  util4.arrayToEnum = /* @__PURE__ */ __name((items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  }, "arrayToEnum");
  util4.getValidEnumValues = /* @__PURE__ */ __name((obj) => {
    const validKeys = (0, util4.objectKeys)(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return (0, util4.objectValues)(filtered);
  }, "getValidEnumValues");
  util4.objectValues = /* @__PURE__ */ __name((obj) => {
    return (0, util4.objectKeys)(obj).map(function(e) {
      return obj[e];
    });
  }, "objectValues");
  util4.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util4.find = /* @__PURE__ */ __name((arr, checker) => {
    for (const item of arr) {
      if (checker(item)) return item;
    }
    return void 0;
  }, "find");
  util4.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util4.joinValues = joinValues;
  __name(joinValues, "joinValues");
  util4.jsonStringifyReplacer = /* @__PURE__ */ __name((_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  }, "jsonStringifyReplacer");
  util4.compareFunctions = /* @__PURE__ */ __name((a, b) => {
    return a.toString() === b.toString();
  }, "compareFunctions");
})(util || (util = {}));
var objectUtil;
((objectUtil3) => {
  objectUtil3.mergeShapes = /* @__PURE__ */ __name((first, second) => {
    return __spreadValues(__spreadValues({}, first), second);
  }, "mergeShapes");
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
function processCreateParams(params) {
  if (!params) return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2) return { errorMap: errorMap2, description, [zuiKey]: params == null ? void 0 : params[zuiKey] };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    if (iss.code !== "invalid_type") return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error != null ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error != null ? invalid_type_error : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description, [zuiKey]: params == null ? void 0 : params[zuiKey] };
}
__name(processCreateParams, "processCreateParams");

// src/z/types/error/locales/en.ts
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    case ZodIssueCode.unresolved_reference:
      message2 = "Unresolved reference";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
}, "errorMap");
var en_default = errorMap;

// src/z/types/error/index.ts
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite",
  "unresolved_reference"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var _ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = /* @__PURE__ */ __name((sub) => {
      this.issues = [...this.issues, sub];
    }, "addIssue");
    this.addIssues = /* @__PURE__ */ __name((subs = []) => {
      this.issues = [...this.issues, ...subs];
    }, "addIssues");
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      ;
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          ;
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_ZodError, "ZodError");
_ZodError.create = /* @__PURE__ */ __name((issues) => {
  const error = new _ZodError(issues);
  return error;
}, "create");
var ZodError = _ZodError;
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// src/z/types/utils/parseUtil.ts
var makeIssue = /* @__PURE__ */ __name((params) => {
  var _a;
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = __spreadProps(__spreadValues({}, issueData), {
    path: fullPath
  });
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return __spreadProps(__spreadValues({}, issueData), {
    path: fullPath,
    message: (_a = issueData.message) != null ? _a : errorMessage
  });
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      getErrorMap(),
      // then global override map
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var _ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted") return INVALID;
      if (s.status === "dirty") status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted") return INVALID;
      if (value.status === "aborted") return INVALID;
      if (key.status === "dirty") status.dirty();
      if (value.status === "dirty") status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(_ParseStatus, "ParseStatus");
var ParseStatus = _ParseStatus;
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// src/z/types/utils/errorUtil.ts
var errorUtil;
((errorUtil2) => {
  errorUtil2.errToObj = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? { message: message2 } : message2 || {}, "errToObj");
  errorUtil2.toString = /* @__PURE__ */ __name((message2) => typeof message2 === "string" ? message2 : message2 == null ? void 0 : message2.message, "toString");
})(errorUtil || (errorUtil = {}));

// src/z/types/any/index.ts
var _ZodAny = class _ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
    this._any = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodAny;
  }
};
__name(_ZodAny, "ZodAny");
_ZodAny.create = /* @__PURE__ */ __name((params) => {
  return new _ZodAny(__spreadValues({
    typeName: "ZodAny" /* ZodAny */
  }, processCreateParams(params)));
}, "create");
var ZodAny = _ZodAny;

// src/z/types/array/index.ts
var _ZodArray = class _ZodArray extends ZodType {
  dereference(defs) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  isEqual(schema) {
    var _a, _b, _c, _d, _e, _f;
    if (!(schema instanceof _ZodArray)) {
      return false;
    }
    return (
      // message is not considered for equality
      isEqual_default((_a = this._def.exactLength) == null ? void 0 : _a.value, (_b = schema._def.exactLength) == null ? void 0 : _b.value) && isEqual_default((_c = this._def.maxLength) == null ? void 0 : _c.value, (_d = schema._def.maxLength) == null ? void 0 : _d.value) && isEqual_default((_e = this._def.minLength) == null ? void 0 : _e.value, (_f = schema._def.minLength) == null ? void 0 : _f.value) && this._def.type.isEqual(schema._def.type)
    );
  }
  _parse(input4) {
    const { ctx, status } = this._processInputParams(input4);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all(
        [...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })
      ).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    }));
  }
  max(maxLength, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    }));
  }
  length(len, message2) {
    return new _ZodArray(__spreadProps(__spreadValues({}, this._def), {
      exactLength: { value: len, message: errorUtil.toString(message2) }
    }));
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
__name(_ZodArray, "ZodArray");
_ZodArray.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodArray(__spreadValues({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: "ZodArray" /* ZodArray */
  }, processCreateParams(params)));
}, "create");
var ZodArray = _ZodArray;

// src/z/types/utils/custom-set.ts
var DEFAULT_OPTIONS = {
  compare: isEqual_default
};
var _CustomSet = class _CustomSet {
  constructor(items = [], opt = {}) {
    this._options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), opt);
    this._items = [];
    for (const i of items) {
      this.add(i);
    }
  }
  get items() {
    return [...this._items];
  }
  get size() {
    return this._items.length;
  }
  has(item) {
    return this._items.some((i) => this._options.compare(i, item));
  }
  add(item) {
    if (!this.has(item)) {
      this._items.push(item);
    }
  }
  isEqual(other) {
    if (this.size !== other.size) {
      return false;
    }
    return this.isSubsetOf(other) && other.isSubsetOf(this);
  }
  isSubsetOf(other) {
    if (this.size > other.size) {
      return false;
    }
    return this._items.every((i) => other.has(i));
  }
};
__name(_CustomSet, "CustomSet");
var CustomSet = _CustomSet;

// src/z/types/bigint/index.ts
var _ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = BigInt(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input4.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBigInt)) {
      return false;
    }
    if (this._def.coerce !== schema._def.coerce) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodBigInt(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodBigInt, "ZodBigInt");
_ZodBigInt.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodBigInt(__spreadValues({
    checks: [],
    typeName: "ZodBigInt" /* ZodBigInt */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodBigInt = _ZodBigInt;

// src/z/types/boolean/index.ts
var _ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Boolean(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBoolean)) return false;
    return this._def.coerce === schema._def.coerce;
  }
};
__name(_ZodBoolean, "ZodBoolean");
_ZodBoolean.create = /* @__PURE__ */ __name((params) => {
  return new _ZodBoolean(__spreadValues({
    typeName: "ZodBoolean" /* ZodBoolean */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodBoolean = _ZodBoolean;

// src/z/types/branded/index.ts
var BRAND = Symbol("zod_brand");
var _ZodBranded = class _ZodBranded extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodBranded)) return false;
    return this._def.type.isEqual(schema._def.type);
  }
};
__name(_ZodBranded, "ZodBranded");
var ZodBranded = _ZodBranded;

// src/z/types/catch/index.ts
var _ZodCatch = class _ZodCatch extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const newCtx = __spreadProps(__spreadValues({}, ctx), {
      common: __spreadProps(__spreadValues({}, ctx.common), {
        issues: []
      })
    });
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: __spreadValues({}, newCtx)
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodCatch)) return false;
    return this._def.innerType.isEqual(schema._def.innerType) && util.compareFunctions(this._def.catchValue, schema._def.catchValue);
  }
};
__name(_ZodCatch, "ZodCatch");
_ZodCatch.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodCatch(__spreadValues({
    innerType: type,
    typeName: "ZodCatch" /* ZodCatch */,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch
  }, processCreateParams(params)));
}, "create");
var ZodCatch = _ZodCatch;

// src/z/types/custom/index.ts
var custom = /* @__PURE__ */ __name((check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) != null ? _a : fatal) != null ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue(__spreadProps(__spreadValues({ code: "custom" }, p2), { fatal: _fatal }));
      }
    });
  return ZodAny.create();
}, "custom");

// src/z/types/date/index.ts
var _ZodDate = class _ZodDate extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = new Date(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input4.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input4.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDate)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks) && this._def.coerce === schema._def.coerce;
  }
};
__name(_ZodDate, "ZodDate");
_ZodDate.create = /* @__PURE__ */ __name((params) => {
  return new _ZodDate(__spreadValues({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: "ZodDate" /* ZodDate */
  }, processCreateParams(params)));
}, "create");
var ZodDate = _ZodDate;

// src/z/types/default/index.ts
var _ZodDefault = class _ZodDefault extends ZodType {
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
  dereference(defs) {
    return new _ZodDefault(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDefault)) return false;
    return this._def.innerType.isEqual(schema._def.innerType) && isEqual_default(this._def.defaultValue(), schema._def.defaultValue());
  }
};
__name(_ZodDefault, "ZodDefault");
_ZodDefault.create = /* @__PURE__ */ __name((type, value, params) => {
  return new _ZodDefault(__spreadValues({
    innerType: type,
    typeName: "ZodDefault" /* ZodDefault */,
    defaultValue: typeof value === "function" ? value : () => value
  }, processCreateParams(params)));
}, "create");
var ZodDefault = _ZodDefault;

// src/z/utils.ts
var unique = /* @__PURE__ */ __name((arr) => {
  return Array.from(new Set(arr));
}, "unique");

// src/z/types/discriminatedUnion/index.ts
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  dereference(defs) {
    const options = this.options.map((option) => option.dereference(defs));
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(this.discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadProps(__spreadValues({}, this._def), {
      options,
      optionsMap
    }));
  }
  getReferences() {
    return unique(this.options.flatMap((option) => option.getReferences()));
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = _ZodDiscriminatedUnion._getOptionsMap(discriminator, options);
    return new _ZodDiscriminatedUnion(__spreadValues({
      typeName: "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */,
      discriminator,
      options,
      optionsMap
    }, processCreateParams(params)));
  }
  static _getOptionsMap(discriminator, options) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(
          `A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`
        );
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return optionsMap;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodDiscriminatedUnion)) return false;
    if (this._def.discriminator !== schema._def.discriminator) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisOptions = new CustomSet(this._def.options, { compare });
    const thatOptions = new CustomSet(schema._def.options, { compare });
    return thisOptions.isEqual(thatOptions);
  }
};
__name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
var ZodDiscriminatedUnion = _ZodDiscriminatedUnion;

// src/z/types/enum/index.ts
function createZodEnum(values, params) {
  return new ZodEnum(__spreadValues({
    values,
    typeName: "ZodEnum" /* ZodEnum */
  }, processCreateParams(params)));
}
__name(createZodEnum, "createZodEnum");
var _ZodEnum = class _ZodEnum extends ZodType {
  _parse(input4) {
    if (typeof input4.data !== "string") {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input4.data) === -1) {
      const ctx = this._getOrReturnCtx(input4);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, __spreadValues(__spreadValues({}, this._def), newDef));
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), __spreadValues(__spreadValues({}, this._def), newDef));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodEnum)) return false;
    const thisValues = new CustomSet(this._def.values);
    const thatValues = new CustomSet(schema._def.values);
    return thisValues.isEqual(thatValues);
  }
};
__name(_ZodEnum, "ZodEnum");
_ZodEnum.create = createZodEnum;
var ZodEnum = _ZodEnum;

// src/z/types/function/index.ts
var _ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  dereference(defs) {
    const args = this._def.args.dereference(defs);
    const returns = this._def.returns.dereference(defs);
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args,
      returns
    }));
  }
  getReferences() {
    return unique([...this._def.args.getReferences(), ...this._def.returns.getReferences()]);
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter(
          (x) => !!x
        ),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    }));
  }
  returns(returnType) {
    return new _ZodFunction(__spreadProps(__spreadValues({}, this._def), {
      returns: returnType
    }));
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction(__spreadValues({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: "ZodFunction" /* ZodFunction */
    }, processCreateParams(params)));
  }
  isEqual(schema) {
    return schema instanceof _ZodFunction && this._def.args.isEqual(schema._def.args) && this._def.returns.isEqual(schema._def.returns);
  }
};
__name(_ZodFunction, "ZodFunction");
var ZodFunction = _ZodFunction;

// src/z/types/intersection/index.ts
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = __spreadValues(__spreadValues({}, a), b);
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var _ZodIntersection = class _ZodIntersection extends ZodType {
  dereference(defs) {
    return new _ZodIntersection(__spreadProps(__spreadValues({}, this._def), {
      left: this._def.left.dereference(defs),
      right: this._def.right.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.left.getReferences(), ...this._def.right.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(
        this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      );
    }
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodIntersection)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisItems = new CustomSet([this._def.left, this._def.right], { compare });
    const thatItems = new CustomSet([schema._def.left, schema._def.right], { compare });
    return thisItems.isEqual(thatItems);
  }
};
__name(_ZodIntersection, "ZodIntersection");
_ZodIntersection.create = /* @__PURE__ */ __name((left, right, params) => {
  return new _ZodIntersection(__spreadValues({
    left,
    right,
    typeName: "ZodIntersection" /* ZodIntersection */
  }, processCreateParams(params)));
}, "create");
var ZodIntersection = _ZodIntersection;

// src/z/types/lazy/index.ts
var _ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodLazy)) return false;
    return this._def.getter().isEqual(schema._def.getter());
  }
};
__name(_ZodLazy, "ZodLazy");
_ZodLazy.create = /* @__PURE__ */ __name((getter, params) => {
  return new _ZodLazy(__spreadValues({
    getter,
    typeName: "ZodLazy" /* ZodLazy */
  }, processCreateParams(params)));
}, "create");
var ZodLazy = _ZodLazy;

// src/z/types/literal/index.ts
var _ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input4) {
    if (input4.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  get value() {
    return this._def.value;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodLiteral)) return false;
    return isEqual_default(this._def.value, schema._def.value);
  }
};
__name(_ZodLiteral, "ZodLiteral");
_ZodLiteral.create = /* @__PURE__ */ __name((value, params) => {
  return new _ZodLiteral(__spreadValues({
    value,
    typeName: "ZodLiteral" /* ZodLiteral */
  }, processCreateParams(params)));
}, "create");
var ZodLiteral = _ZodLiteral;

// src/z/types/map/index.ts
var _ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodMap(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodMap)) return false;
    if (!this._def.keyType.isEqual(schema._def.keyType)) return false;
    if (!this._def.valueType.isEqual(schema._def.valueType)) return false;
    return true;
  }
};
__name(_ZodMap, "ZodMap");
_ZodMap.create = /* @__PURE__ */ __name((keyType, valueType, params) => {
  return new _ZodMap(__spreadValues({
    valueType,
    keyType,
    typeName: "ZodMap" /* ZodMap */
  }, processCreateParams(params)));
}, "create");
var ZodMap = _ZodMap;

// src/z/types/nan/index.ts
var _ZodNaN = class _ZodNaN extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input4.data };
  }
  isEqual(schema) {
    return schema instanceof _ZodNaN;
  }
};
__name(_ZodNaN, "ZodNaN");
_ZodNaN.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNaN(__spreadValues({
    typeName: "ZodNaN" /* ZodNaN */
  }, processCreateParams(params)));
}, "create");
var ZodNaN = _ZodNaN;

// src/z/types/nativeEnum/index.ts
var _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  _parse(input4) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input4);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input4.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  get enum() {
    return this._def.values;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNativeEnum)) return false;
    return isEqual_default(this._def.values, schema._def.values);
  }
};
__name(_ZodNativeEnum, "ZodNativeEnum");
_ZodNativeEnum.create = /* @__PURE__ */ __name((values, params) => {
  return new _ZodNativeEnum(__spreadValues({
    values,
    typeName: "ZodNativeEnum" /* ZodNativeEnum */
  }, processCreateParams(params)));
}, "create");
var ZodNativeEnum = _ZodNativeEnum;

// src/z/types/never/index.ts
var _ZodNever = class _ZodNever extends ZodType {
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
  isEqual(schema) {
    return schema instanceof _ZodNever;
  }
};
__name(_ZodNever, "ZodNever");
_ZodNever.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNever(__spreadValues({
    typeName: "ZodNever" /* ZodNever */
  }, processCreateParams(params)));
}, "create");
var ZodNever = _ZodNever;

// src/z/types/null/index.ts
var _ZodNull = class _ZodNull extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodNull;
  }
};
__name(_ZodNull, "ZodNull");
_ZodNull.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNull(__spreadValues({
    typeName: "ZodNull" /* ZodNull */
  }, processCreateParams(params)));
}, "create");
var ZodNull = _ZodNull;

// src/z/types/nullable/index.ts
var _ZodNullable = class _ZodNullable extends ZodType {
  dereference(defs) {
    return new _ZodNullable(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNullable)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
};
__name(_ZodNullable, "ZodNullable");
_ZodNullable.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodNullable(__spreadValues({
    innerType: type,
    typeName: "ZodNullable" /* ZodNullable */
  }, processCreateParams(params)));
}, "create");
var ZodNullable = _ZodNullable;

// src/z/types/number/index.ts
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var _ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = Number(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input4.data < check.value : input4.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input4.data > check.value : input4.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input4.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    }));
  }
  _addCheck(check) {
    return new _ZodNumber(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodNumber)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
};
__name(_ZodNumber, "ZodNumber");
_ZodNumber.create = /* @__PURE__ */ __name((params) => {
  return new _ZodNumber(__spreadValues({
    checks: [],
    typeName: "ZodNumber" /* ZodNumber */,
    coerce: (params == null ? void 0 : params.coerce) || false
  }, processCreateParams(params)));
}, "create");
var ZodNumber = _ZodNumber;

// src/z/types/object/index.ts
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2(__spreadProps(__spreadValues({}, schema._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  } else if (schema instanceof ZodArray) {
    return new ZodArray(__spreadProps(__spreadValues({}, schema._def), {
      type: deepPartialify(schema.element)
    }));
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var _ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    this.nonstrict = this.passthrough;
    // extend<
    //   Augmentation extends ZodRawShape,
    //   NewOutput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   }>,
    //   NewInput extends util.flatten<{
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }>
    // >(
    //   augmentation: Augmentation
    // ): ZodObject<
    //   extendShape<T, Augmentation>,
    //   UnknownKeys,
    //   Catchall,
    //   NewOutput,
    //   NewInput
    // > {
    //   return new ZodObject({
    //     ...this._def,
    //     shape: () => ({
    //       ...this._def.shape(),
    //       ...augmentation,
    //     }),
    //   }) as any;
    // }
    /**
     * @deprecated Use `.extend` instead
     *  */
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  dereference(defs) {
    const currentShape = this._def.shape();
    const shape = {};
    for (const key in currentShape) {
      shape[key] = currentShape[key].dereference(defs);
    }
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  getReferences() {
    const shape = this._def.shape();
    const refs = [];
    for (const key in shape) {
      refs.push(...shape[key].getReferences());
    }
    return unique(refs);
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input4);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject(__spreadValues(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strict"
    }), message2 !== void 0 ? {
      errorMap: /* @__PURE__ */ __name((issue, ctx) => {
        var _a, _b, _c, _d;
        const defaultError = (_c = (_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) != null ? _c : ctx.defaultError;
        if (issue.code === "unrecognized_keys")
          return {
            message: (_d = errorUtil.errToObj(message2).message) != null ? _d : defaultError
          };
        return {
          message: defaultError
        };
      }, "errorMap")
    } : {}));
  }
  strip() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => __spreadValues(__spreadValues({}, this._def.shape()), augmentation), "shape")
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => __spreadValues(__spreadValues({}, this._def.shape()), merging._def.shape()), "shape"),
      typeName: "ZodObject" /* ZodObject */
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      catchall: index
    }));
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema == null ? void 0 : fieldSchema.optional();
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject(__spreadProps(__spreadValues({}, this._def), {
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    }));
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodObject)) return false;
    if (!this._def.catchall.isEqual(schema._def.catchall)) return false;
    if (this._def.unknownKeys !== schema._def.unknownKeys) return false;
    const thisShape = this._def.shape();
    const thatShape = schema._def.shape();
    const compare = /* @__PURE__ */ __name((a, b) => a[0] === b[0] && a[1].isEqual(b[1]), "compare");
    const thisProps = new CustomSet(Object.entries(thisShape), { compare });
    const thatProps = new CustomSet(Object.entries(thatShape), { compare });
    return thisProps.isEqual(thatProps);
  }
};
__name(_ZodObject, "ZodObject");
_ZodObject.create = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "create");
_ZodObject.strictCreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "strictCreate");
_ZodObject.lazycreate = /* @__PURE__ */ __name((shape, params) => {
  return new _ZodObject(__spreadValues({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: "ZodObject" /* ZodObject */
  }, processCreateParams(params)));
}, "lazycreate");
var ZodObject2 = _ZodObject;

// src/z/types/optional/index.ts
var _ZodOptional = class _ZodOptional extends ZodType {
  dereference(defs) {
    return new _ZodOptional(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input4);
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodOptional)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
};
__name(_ZodOptional, "ZodOptional");
_ZodOptional.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodOptional(__spreadValues({
    innerType: type,
    typeName: "ZodOptional" /* ZodOptional */
  }, processCreateParams(params)));
}, "create");
var ZodOptional = _ZodOptional;

// src/z/types/pipeline/index.ts
var _ZodPipeline = class _ZodPipeline extends ZodType {
  dereference(defs) {
    return new _ZodPipeline(__spreadProps(__spreadValues({}, this._def), {
      in: this._def.in.dereference(defs),
      out: this._def.out.dereference(defs)
    }));
  }
  getReferences() {
    return unique([...this._def.in.getReferences(), ...this._def.out.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted") return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: "ZodPipeline" /* ZodPipeline */
    });
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodPipeline)) return false;
    if (!this._def.in.isEqual(schema._def.in)) return false;
    if (!this._def.out.isEqual(schema._def.out)) return false;
    return true;
  }
};
__name(_ZodPipeline, "ZodPipeline");
var ZodPipeline = _ZodPipeline;

// src/z/types/promise/index.ts
var _ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  dereference(defs) {
    return new _ZodPromise(__spreadProps(__spreadValues({}, this._def), {
      type: this._def.type.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.type.getReferences();
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(
      promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      })
    );
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodPromise)) return false;
    return this._def.type.isEqual(schema._def.type);
  }
};
__name(_ZodPromise, "ZodPromise");
_ZodPromise.create = /* @__PURE__ */ __name((schema, params) => {
  return new _ZodPromise(__spreadValues({
    type: schema,
    typeName: "ZodPromise" /* ZodPromise */
  }, processCreateParams(params)));
}, "create");
var ZodPromise = _ZodPromise;

// src/z/types/readonly/index.ts
var _ZodReadonly = class _ZodReadonly extends ZodType {
  dereference(defs) {
    return new _ZodReadonly(__spreadProps(__spreadValues({}, this._def), {
      innerType: this._def.innerType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.innerType.getReferences();
  }
  _parse(input4) {
    const result = this._def.innerType._parse(input4);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
  unwrap() {
    return this._def.innerType;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodReadonly)) return false;
    return this._def.innerType.isEqual(schema._def.innerType);
  }
};
__name(_ZodReadonly, "ZodReadonly");
_ZodReadonly.create = /* @__PURE__ */ __name((type, params) => {
  return new _ZodReadonly(__spreadValues({
    innerType: type,
    typeName: "ZodReadonly" /* ZodReadonly */
  }, processCreateParams(params)));
}, "create");
var ZodReadonly = _ZodReadonly;

// src/z/types/record/index.ts
var _ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  dereference(defs) {
    const keyType = this._def.keyType.dereference(defs);
    const valueType = this._def.valueType.dereference(defs);
    return new _ZodRecord(__spreadProps(__spreadValues({}, this._def), {
      keyType,
      valueType
    }));
  }
  getReferences() {
    return unique([...this._def.keyType.getReferences(), ...this._def.valueType.getReferences()]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord(__spreadValues({
        keyType: first,
        valueType: second,
        typeName: "ZodRecord" /* ZodRecord */
      }, processCreateParams(third)));
    }
    return new _ZodRecord(__spreadValues({
      keyType: ZodString.create(),
      valueType: first,
      typeName: "ZodRecord" /* ZodRecord */
    }, processCreateParams(second)));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodRecord)) return false;
    if (!this._def.keyType.isEqual(schema._def.keyType)) return false;
    if (!this._def.valueType.isEqual(schema._def.valueType)) return false;
    return true;
  }
};
__name(_ZodRecord, "ZodRecord");
var ZodRecord = _ZodRecord;

// src/z/types/ref/index.ts
var _ZodRef = class _ZodRef extends ZodType {
  dereference(defs) {
    const def = defs[this._def.uri];
    if (!def) {
      return this;
    }
    return def;
  }
  getReferences() {
    return [this._def.uri];
  }
  _parse(input4) {
    const ctx = this._getOrReturnCtx(input4);
    addIssueToContext(ctx, {
      code: ZodIssueCode.unresolved_reference
    });
    return INVALID;
  }
  isOptional() {
    return false;
  }
  isNullable() {
    return false;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodRef)) return false;
    return this._def.uri === schema._def.uri;
  }
};
__name(_ZodRef, "ZodRef");
_ZodRef.create = /* @__PURE__ */ __name((uri) => {
  return new _ZodRef({
    typeName: "ZodRef" /* ZodRef */,
    uri
  });
}, "create");
var ZodRef = _ZodRef;

// src/z/types/set/index.ts
var _ZodSet = class _ZodSet extends ZodType {
  dereference(defs) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      valueType: this._def.valueType.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.valueType.getReferences();
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted") return INVALID;
        if (element.status === "dirty") status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map(
      (item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i))
    );
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    }));
  }
  max(maxSize, message2) {
    return new _ZodSet(__spreadProps(__spreadValues({}, this._def), {
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    }));
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
  isEqual(schema) {
    var _a, _b, _c, _d;
    if (!(schema instanceof _ZodSet)) return false;
    const thisMin = (_a = this._def.minSize) == null ? void 0 : _a.value;
    const thatMin = (_b = schema._def.minSize) == null ? void 0 : _b.value;
    if (thisMin !== thatMin) return false;
    const thisMax = (_c = this._def.maxSize) == null ? void 0 : _c.value;
    const thatMax = (_d = schema._def.maxSize) == null ? void 0 : _d.value;
    if (thisMax !== thatMax) return false;
    return this._def.valueType.isEqual(schema._def.valueType);
  }
};
__name(_ZodSet, "ZodSet");
_ZodSet.create = /* @__PURE__ */ __name((valueType, params) => {
  return new _ZodSet(__spreadValues({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: "ZodSet" /* ZodSet */
  }, processCreateParams(params)));
}, "create");
var ZodSet = _ZodSet;

// src/z/types/string/index.ts
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var isEmojiRegex = /* @__PURE__ */ __name((value) => value === _emojiRegex, "isEmojiRegex");
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = /* @__PURE__ */ __name((args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(
        `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
      );
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
}, "datetimeRegex");
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var _ZodString = class _ZodString extends ZodType {
  _parse(input4) {
    if (this._def.coerce) {
      input4.data = String(input4.data);
    }
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input4);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input4.data.length < check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input4.data.length > check.value) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input4.data.length > check.value;
        const tooSmall = input4.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input4, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input4.data);
        } catch (e) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input4.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input4.data = input4.data.trim();
      } else if (check.kind === "includes") {
        if (!input4.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input4.data = input4.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input4.data = input4.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input4.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input4.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input4.data)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input4.data, check.version)) {
          ctx = this._getOrReturnCtx(input4, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input4.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), __spreadValues({
      validation,
      code: ZodIssueCode.invalid_string
    }, errorUtil.errToObj(message2)));
  }
  _addCheck(check) {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, check]
    }));
  }
  email(message2) {
    return this._addCheck(__spreadValues({ kind: "email" }, errorUtil.errToObj(message2)));
  }
  url(message2) {
    return this._addCheck(__spreadValues({ kind: "url" }, errorUtil.errToObj(message2)));
  }
  emoji(message2) {
    return this._addCheck(__spreadValues({ kind: "emoji" }, errorUtil.errToObj(message2)));
  }
  uuid(message2) {
    return this._addCheck(__spreadValues({ kind: "uuid" }, errorUtil.errToObj(message2)));
  }
  cuid(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid" }, errorUtil.errToObj(message2)));
  }
  cuid2(message2) {
    return this._addCheck(__spreadValues({ kind: "cuid2" }, errorUtil.errToObj(message2)));
  }
  ulid(message2) {
    return this._addCheck(__spreadValues({ kind: "ulid" }, errorUtil.errToObj(message2)));
  }
  ip(options) {
    return this._addCheck(__spreadValues({ kind: "ip" }, errorUtil.errToObj(options)));
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck(__spreadValues({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (_a = options == null ? void 0 : options.offset) != null ? _a : false
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  regex(regex, message2) {
    return this._addCheck(__spreadValues({
      kind: "regex",
      regex
    }, errorUtil.errToObj(message2)));
  }
  includes(value, options) {
    return this._addCheck(__spreadValues({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position
    }, errorUtil.errToObj(options == null ? void 0 : options.message)));
  }
  startsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "startsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  endsWith(value, message2) {
    return this._addCheck(__spreadValues({
      kind: "endsWith",
      value
    }, errorUtil.errToObj(message2)));
  }
  min(minLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "min",
      value: minLength
    }, errorUtil.errToObj(message2)));
  }
  max(maxLength, message2) {
    return this._addCheck(__spreadValues({
      kind: "max",
      value: maxLength
    }, errorUtil.errToObj(message2)));
  }
  length(len, message2) {
    return this._addCheck(__spreadValues({
      kind: "length",
      value: len
    }, errorUtil.errToObj(message2)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  secret() {
    this._def[zuiKey] = __spreadProps(__spreadValues({}, this._def[zuiKey]), { secret: true });
    return this;
  }
  toLowerCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new _ZodString(__spreadProps(__spreadValues({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min) min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max) max = ch.value;
      }
    }
    return max;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodString)) return false;
    const thisChecks = new CustomSet(this._def.checks);
    const thatChecks = new CustomSet(schema._def.checks);
    return thisChecks.isEqual(thatChecks);
  }
};
__name(_ZodString, "ZodString");
_ZodString.create = /* @__PURE__ */ __name((params) => {
  var _a;
  return new _ZodString(__spreadValues({
    checks: [],
    typeName: "ZodString" /* ZodString */,
    coerce: (_a = params == null ? void 0 : params.coerce) != null ? _a : false
  }, processCreateParams(params)));
}, "create");
var ZodString = _ZodString;

// src/z/types/symbol/index.ts
var _ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodSymbol;
  }
};
__name(_ZodSymbol, "ZodSymbol");
_ZodSymbol.create = /* @__PURE__ */ __name((params) => {
  return new _ZodSymbol(__spreadValues({
    typeName: "ZodSymbol" /* ZodSymbol */
  }, processCreateParams(params)));
}, "create");
var ZodSymbol = _ZodSymbol;

// src/z/types/transformer/index.ts
var _ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" /* ZodEffects */ ? this._def.schema.sourceType() : this._def.schema;
  }
  dereference(defs) {
    return new _ZodEffects(__spreadProps(__spreadValues({}, this._def), {
      schema: this._def.schema.dereference(defs)
    }));
  }
  getReferences() {
    return this._def.schema.getReferences();
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted") return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted") return INVALID;
          if (result.status === "dirty") return DIRTY(result.value);
          if (status.value === "dirty") return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted") return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted") return INVALID;
        if (result.status === "dirty") return DIRTY(result.value);
        if (status.value === "dirty") return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted") return INVALID;
        if (inner.status === "dirty") status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted") return INVALID;
          if (inner.status === "dirty") status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base)) return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(
            `Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`
          );
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base)) return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodEffects)) return false;
    if (!this._def.schema.isEqual(schema._def.schema)) return false;
    if (this._def.effect.type === "refinement") {
      if (schema._def.effect.type !== "refinement") return false;
      return util.compareFunctions(this._def.effect.refinement, schema._def.effect.refinement);
    }
    if (this._def.effect.type === "transform") {
      if (schema._def.effect.type !== "transform") return false;
      return util.compareFunctions(this._def.effect.transform, schema._def.effect.transform);
    }
    if (this._def.effect.type === "preprocess") {
      if (schema._def.effect.type !== "preprocess") return false;
      return util.compareFunctions(this._def.effect.transform, schema._def.effect.transform);
    }
    util.assertNever(this._def.effect);
    return false;
  }
};
__name(_ZodEffects, "ZodEffects");
_ZodEffects.create = /* @__PURE__ */ __name((schema, effect, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    typeName: "ZodEffects" /* ZodEffects */,
    effect
  }, processCreateParams(params)));
}, "create");
_ZodEffects.createWithPreprocess = /* @__PURE__ */ __name((preprocess, schema, params) => {
  return new _ZodEffects(__spreadValues({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: "ZodEffects" /* ZodEffects */
  }, processCreateParams(params)));
}, "createWithPreprocess");
var ZodEffects = _ZodEffects;

// src/z/types/tuple/index.ts
var _ZodTuple = class _ZodTuple extends ZodType {
  dereference(defs) {
    const items = this._def.items.map((item) => item.dereference(defs));
    const rest = this._def.rest ? this._def.rest.dereference(defs) : null;
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      items,
      rest
    }));
  }
  getReferences() {
    return unique([
      ...this._def.items.flatMap((item) => item.getReferences()),
      ...this._def.rest ? this._def.rest.getReferences() : []
    ]);
  }
  _parse(input4) {
    const { status, ctx } = this._processInputParams(input4);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema) return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple(__spreadProps(__spreadValues({}, this._def), {
      rest
    }));
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodTuple)) return false;
    if (!this._restEquals(schema)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisItems = new CustomSet(this._def.items, { compare });
    const schemaItems = new CustomSet(schema._def.items, { compare });
    return thisItems.isEqual(schemaItems);
  }
  _restEquals(schema) {
    if (this._def.rest === null) {
      return schema._def.rest === null;
    }
    return schema._def.rest !== null && this._def.rest.isEqual(schema._def.rest);
  }
};
__name(_ZodTuple, "ZodTuple");
_ZodTuple.create = /* @__PURE__ */ __name((schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new _ZodTuple(__spreadValues({
    items: schemas,
    typeName: "ZodTuple" /* ZodTuple */,
    rest: null
  }, processCreateParams(params)));
}, "create");
var ZodTuple = _ZodTuple;

// src/z/types/undefined/index.ts
var _ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodUndefined;
  }
};
__name(_ZodUndefined, "ZodUndefined");
_ZodUndefined.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUndefined(__spreadValues({
    typeName: "ZodUndefined" /* ZodUndefined */
  }, processCreateParams(params)));
}, "create");
var ZodUndefined = _ZodUndefined;

// src/z/types/union/index.ts
var _ZodUnion = class _ZodUnion extends ZodType {
  dereference(defs) {
    const options = this._def.options.map((option) => option.dereference(defs));
    return new _ZodUnion(__spreadProps(__spreadValues({}, this._def), {
      options
    }));
  }
  getReferences() {
    return unique(
      this._def.options.reduce((acc, option) => {
        return [...acc, ...option.getReferences()];
      }, [])
    );
  }
  _parse(input4) {
    const { ctx } = this._processInputParams(input4);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(
        options.map(async (option) => {
          const childCtx = __spreadProps(__spreadValues({}, ctx), {
            common: __spreadProps(__spreadValues({}, ctx.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })
      ).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = __spreadProps(__spreadValues({}, ctx), {
          common: __spreadProps(__spreadValues({}, ctx.common), {
            issues: []
          }),
          parent: null
        });
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
  isEqual(schema) {
    if (!(schema instanceof _ZodUnion)) return false;
    const compare = /* @__PURE__ */ __name((a, b) => a.isEqual(b), "compare");
    const thisOptions = new CustomSet([...this._def.options], { compare });
    const thatOptions = new CustomSet([...schema._def.options], { compare });
    return thisOptions.isEqual(thatOptions);
  }
};
__name(_ZodUnion, "ZodUnion");
_ZodUnion.create = /* @__PURE__ */ __name((types, params) => {
  return new _ZodUnion(__spreadValues({
    options: types,
    typeName: "ZodUnion" /* ZodUnion */
  }, processCreateParams(params)));
}, "create");
var ZodUnion = _ZodUnion;

// src/z/types/unknown/index.ts
var _ZodUnknown = class _ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    // required
    this._unknown = true;
  }
  _parse(input4) {
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodUnknown;
  }
};
__name(_ZodUnknown, "ZodUnknown");
_ZodUnknown.create = /* @__PURE__ */ __name((params) => {
  return new _ZodUnknown(__spreadValues({
    typeName: "ZodUnknown" /* ZodUnknown */
  }, processCreateParams(params)));
}, "create");
var ZodUnknown = _ZodUnknown;

// src/z/types/void/index.ts
var _ZodVoid = class _ZodVoid extends ZodType {
  _parse(input4) {
    const parsedType = this._getType(input4);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input4);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input4.data);
  }
  isEqual(schema) {
    return schema instanceof _ZodVoid;
  }
};
__name(_ZodVoid, "ZodVoid");
_ZodVoid.create = /* @__PURE__ */ __name((params) => {
  return new _ZodVoid(__spreadValues({
    typeName: "ZodVoid" /* ZodVoid */
  }, processCreateParams(params)));
}, "create");
var ZodVoid = _ZodVoid;

// src/transforms/object-to-zui/index.ts
var dateTimeRegex = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/;
var objectToZui = /* @__PURE__ */ __name((obj, opts, isRoot = true) => {
  if (typeof obj !== "object") {
    throw new ObjectToZuiError("Input must be an object");
  }
  const applyOptions = /* @__PURE__ */ __name((zodType) => {
    let newType = zodType;
    if (opts == null ? void 0 : opts.nullable) {
      newType = newType.nullable();
    }
    if (opts == null ? void 0 : opts.optional) {
      newType = newType.optional();
    }
    if ((opts == null ? void 0 : opts.passtrough) && typeof newType.passthrough === "function") {
      newType = newType.passthrough();
    }
    return newType;
  }, "applyOptions");
  const schema = Object.entries(obj).reduce((acc, [key, value]) => {
    if (value === null) {
      acc[key] = applyOptions(z_exports.null());
    } else {
      switch (typeof value) {
        case "string":
          acc[key] = dateTimeRegex.test(value) ? applyOptions(z_exports.string().datetime()) : applyOptions(z_exports.string());
          break;
        case "number":
          acc[key] = applyOptions(z_exports.number());
          break;
        case "boolean":
          acc[key] = applyOptions(z_exports.boolean());
          break;
        case "object":
          if (Array.isArray(value)) {
            if (value.length === 0) {
              acc[key] = applyOptions(z_exports.array(z_exports.unknown()));
            } else if (typeof value[0] === "object") {
              acc[key] = applyOptions(z_exports.array(objectToZui(value[0], opts, false)));
            } else if (["string", "number", "boolean"].includes(typeof value[0])) {
              acc[key] = applyOptions(z_exports.array(z_exports[typeof value[0]]()));
            }
          } else {
            acc[key] = applyOptions(objectToZui(value, opts, false));
          }
          break;
        default:
          throw new ObjectToZuiError(`Unsupported type for key ${key}`);
      }
    }
    return acc;
  }, {});
  const hasProperties = Object.keys(schema).length > 0;
  if ((opts == null ? void 0 : opts.passtrough) || !isRoot && !hasProperties) {
    return z_exports.object(schema).passthrough();
  }
  return z_exports.object(schema);
}, "objectToZui");

// src/transforms/zui-to-json-schema/parsers/any.ts
function parseAnyDef() {
  return {};
}
__name(parseAnyDef, "parseAnyDef");

// src/transforms/zui-to-json-schema/errorMessages.ts
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages)) return;
  if (errorMessage) {
    res.errorMessage = __spreadProps(__spreadValues({}, res.errorMessage), {
      [key]: errorMessage
    });
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// src/transforms/zui-to-json-schema/parsers/array.ts
function parseArrayDef(def, refs) {
  var _a, _b;
  const res = {
    type: "array"
  };
  if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== "ZodAny" /* ZodAny */) {
    res.items = parseDef(def.type._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "items"]
    }));
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");

// src/transforms/zui-to-json-schema/parsers/bigint.ts
function parseBigintDef(def, refs) {
  const res = __spreadValues({
    type: "integer",
    format: "int64"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");

// src/transforms/zui-to-json-schema/parsers/boolean.ts
function parseBooleanDef(def) {
  return __spreadValues({
    type: "boolean"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
}
__name(parseBooleanDef, "parseBooleanDef");

// src/transforms/zui-to-json-schema/parsers/branded.ts
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");

// src/transforms/zui-to-json-schema/parsers/catch.ts
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");

// src/transforms/zui-to-json-schema/parsers/date.ts
function parseDateDef(def, refs) {
  if (refs.dateStrategy == "integer") {
    return integerDateParser(def, refs);
  } else {
    return __spreadValues({
      type: "string",
      format: "date-time"
    }, def.coerce ? {
      [zuiKey]: {
        coerce: def.coerce || void 0
      }
    } : {});
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def, refs) => {
  const res = __spreadValues({
    type: "integer",
    format: "unix-time"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "minimum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          setResponseValueAndErrors(
            res,
            "maximum",
            check.value,
            // This is in milliseconds
            check.message,
            refs
          );
        }
        break;
    }
  }
  return res;
}, "integerDateParser");

// src/transforms/zui-to-json-schema/parsers/default.ts
function parseDefaultDef(_def, refs) {
  return __spreadProps(__spreadValues({}, parseDef(_def.innerType._def, refs)), {
    default: _def.defaultValue()
  });
}
__name(parseDefaultDef, "parseDefaultDef");

// src/transforms/zui-to-json-schema/parsers/effects.ts
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}
__name(parseEffectsDef, "parseEffectsDef");

// src/transforms/zui-to-json-schema/parsers/enum.ts
function parseEnumDef(def) {
  return {
    type: "string",
    enum: def.values
  };
}
__name(parseEnumDef, "parseEnumDef");

// src/transforms/zui-to-json-schema/parsers/intersection.ts
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "0"]
    })),
    parseDef(def.right._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "allOf", "1"]
    }))
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const _a = schema, { additionalProperties } = _a, rest = __objRest(_a, ["additionalProperties"]);
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? __spreadValues({
    allOf: mergedAllOf
  }, unevaluatedProperties) : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");

// src/transforms/zui-to-json-schema/parsers/literal.ts
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");

// src/transforms/zui-to-json-schema/parsers/string.ts
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function parseStringDef(def, refs) {
  const res = __spreadValues({
    type: "string"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  __name(processPattern, "processPattern");
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "max":
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex.source, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, "^" + processPattern(check.value), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, processPattern(check.value) + "$", check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(
            res,
            "minLength",
            typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value,
            check.message,
            refs
          );
          setResponseValueAndErrors(
            res,
            "maxLength",
            typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value,
            check.message,
            refs
          );
          break;
        case "includes": {
          addPattern(res, processPattern(check.value), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ;
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
var escapeNonAlphaNumeric = /* @__PURE__ */ __name((value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join(""), "escapeNonAlphaNumeric");
var addFormat = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push(__spreadValues({
        format: schema.format
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { format: schema.errorMessage.format }
      }));
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push(__spreadValues({
      format: value
    }, message2 && refs.errorMessages && { errorMessage: { format: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "format", value, message2, refs);
  }
}, "addFormat");
var addPattern = /* @__PURE__ */ __name((schema, value, message2, refs) => {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push(__spreadValues({
        pattern: schema.pattern
      }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { pattern: schema.errorMessage.pattern }
      }));
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push(__spreadValues({
      pattern: value
    }, message2 && refs.errorMessages && { errorMessage: { pattern: message2 } }));
  } else {
    setResponseValueAndErrors(schema, "pattern", value, message2, refs);
  }
}, "addPattern");

// src/transforms/zui-to-json-schema/parsers/record.ts
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e;
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce(
        (acc, key) => {
          var _a2;
          return __spreadProps(__spreadValues({}, acc), {
            [key]: (_a2 = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
              currentPath: [...refs.currentPath, "properties", key]
            }))) != null ? _a2 : {}
          });
        },
        {}
      ),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: (_b = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _b : {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_c = def.keyType) == null ? void 0 : _c._def.typeName) === "ZodString" /* ZodString */ && ((_d = def.keyType._def.checks) == null ? void 0 : _d.length)) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce(
      (acc, [key, value]) => key === "type" ? acc : __spreadProps(__spreadValues({}, acc), { [key]: value }),
      {}
    );
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: keyType
    });
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === "ZodEnum" /* ZodEnum */) {
    return __spreadProps(__spreadValues({}, schema), {
      propertyNames: {
        enum: def.keyType._def.values
      }
    });
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");

// src/transforms/zui-to-json-schema/parsers/map.ts
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys2 = parseDef(def.keyType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "0"]
  })) || {};
  const values = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys2, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");

// src/transforms/zui-to-json-schema/parsers/nativeEnum.ts
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues.filter(
      (value) => typeof value === "string" || typeof value === "number"
    )
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");

// src/transforms/zui-to-json-schema/parsers/never.ts
function parseNeverDef() {
  return {
    not: {}
  };
}
__name(parseNeverDef, "parseNeverDef");

// src/transforms/zui-to-json-schema/parsers/null.ts
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");

// src/transforms/zui-to-json-schema/parsers/union.ts
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3") return asUnionOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null) return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))],
        []
      )
    };
  }
  return asUnionOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asUnionOf = /* @__PURE__ */ __name((def, refs) => {
  const unionOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, refs.unionStrategy, `${i}`]
    }))
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  const discriminator = refs.discriminator && def.typeName === "ZodDiscriminatedUnion" && typeof def.discriminator === "string" ? { discriminator: { propertyName: def.discriminator } } : {};
  if (!unionOf.length) {
    return void 0;
  }
  return refs.unionStrategy === "anyOf" ? __spreadValues({ anyOf: unionOf }, discriminator) : __spreadValues({ oneOf: unionOf }, discriminator);
}, "asUnionOf");

// src/transforms/zui-to-json-schema/parsers/nullable.ts
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath]
    }));
    return base2 && __spreadProps(__spreadValues({}, base2), { nullable: true });
  }
  const base = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "0"]
  }));
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");

// src/transforms/zui-to-json-schema/parsers/number.ts
function parseNumberDef(def, refs) {
  const res = __spreadValues({
    type: "number"
  }, def.coerce ? {
    [zuiKey]: {
      coerce: def.coerce || void 0
    }
  } : {});
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");

// src/transforms/zui-to-json-schema/parsers/object.ts
function parseObjectDef(def, refs) {
  var _a;
  const result = __spreadProps(__spreadValues({
    type: "object"
  }, Object.entries(def.shape()).reduce(
    (acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0) return acc;
      const parsedDef = parseDef(propDef._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "properties", propName],
        propertyPath: [...refs.currentPath, "properties", propName]
      }));
      if (parsedDef === void 0) return acc;
      return {
        properties: __spreadProps(__spreadValues({}, acc.properties), { [propName]: parsedDef }),
        required: propDef.isOptional() ? acc.required : [...acc.required, propName]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_a = parseDef(def.catchall._def, __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.currentPath, "additionalProperties"]
    }))) != null ? _a : true
  });
  if (!result.required.length) delete result.required;
  return result;
}
__name(parseObjectDef, "parseObjectDef");

// src/transforms/zui-to-json-schema/parsers/optional.ts
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "anyOf", "1"]
  }));
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
}, "parseOptionalDef");

// src/transforms/zui-to-json-schema/parsers/pipeline.ts
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", "0"]
  }));
  const b = parseDef(def.out._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  }));
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// src/transforms/zui-to-json-schema/parsers/promise.ts
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");

// src/transforms/zui-to-json-schema/parsers/set.ts
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, __spreadProps(__spreadValues({}, refs), {
    currentPath: [...refs.currentPath, "items"]
  }));
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");

// src/transforms/zui-to-json-schema/parsers/tuple.ts
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, __spreadProps(__spreadValues({}, refs), {
        currentPath: [...refs.currentPath, "additionalItems"]
      }))
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, __spreadProps(__spreadValues({}, refs), {
          currentPath: [...refs.currentPath, "items", `${i}`]
        }))
      ).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");

// src/transforms/zui-to-json-schema/parsers/undefined.ts
function parseUndefinedDef() {
  return {
    not: {}
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");

// src/transforms/zui-to-json-schema/parsers/unknown.ts
function parseUnknownDef() {
  return {};
}
__name(parseUnknownDef, "parseUnknownDef");

// src/transforms/zui-to-json-schema/parsers/readonly.ts
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");

// src/transforms/zui-to-json-schema/parsers/ref.ts
function parseRefDef(def) {
  return {
    $ref: def.uri
  };
}
__name(parseRefDef, "parseRefDef");

// src/transforms/zui-to-json-schema/parseDef.ts
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
}, "get$ref");
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case "ZodString" /* ZodString */:
      return parseStringDef(def, refs);
    case "ZodNumber" /* ZodNumber */:
      return parseNumberDef(def, refs);
    case "ZodObject" /* ZodObject */:
      return parseObjectDef(def, refs);
    case "ZodBigInt" /* ZodBigInt */:
      return parseBigintDef(def, refs);
    case "ZodBoolean" /* ZodBoolean */:
      return parseBooleanDef(def);
    case "ZodDate" /* ZodDate */:
      return parseDateDef(def, refs);
    case "ZodUndefined" /* ZodUndefined */:
      return parseUndefinedDef();
    case "ZodNull" /* ZodNull */:
      return parseNullDef(refs);
    case "ZodArray" /* ZodArray */:
      return parseArrayDef(def, refs);
    case "ZodUnion" /* ZodUnion */:
    case "ZodDiscriminatedUnion" /* ZodDiscriminatedUnion */:
      return parseUnionDef(def, refs);
    case "ZodIntersection" /* ZodIntersection */:
      return parseIntersectionDef(def, refs);
    case "ZodTuple" /* ZodTuple */:
      return parseTupleDef(def, refs);
    case "ZodRecord" /* ZodRecord */:
      return parseRecordDef(def, refs);
    case "ZodRef" /* ZodRef */:
      return parseRefDef(def);
    case "ZodLiteral" /* ZodLiteral */:
      return parseLiteralDef(def, refs);
    case "ZodEnum" /* ZodEnum */:
      return parseEnumDef(def);
    case "ZodNativeEnum" /* ZodNativeEnum */:
      return parseNativeEnumDef(def);
    case "ZodNullable" /* ZodNullable */:
      return parseNullableDef(def, refs);
    case "ZodOptional" /* ZodOptional */:
      return parseOptionalDef(def, refs);
    case "ZodMap" /* ZodMap */:
      return parseMapDef(def, refs);
    case "ZodSet" /* ZodSet */:
      return parseSetDef(def, refs);
    case "ZodLazy" /* ZodLazy */:
      return parseDef(def.getter()._def, refs);
    case "ZodPromise" /* ZodPromise */:
      return parsePromiseDef(def, refs);
    case "ZodNaN" /* ZodNaN */:
    case "ZodNever" /* ZodNever */:
      return parseNeverDef();
    case "ZodEffects" /* ZodEffects */:
      return parseEffectsDef(def, refs);
    case "ZodAny" /* ZodAny */:
      return parseAnyDef();
    case "ZodUnknown" /* ZodUnknown */:
      return parseUnknownDef();
    case "ZodDefault" /* ZodDefault */:
      return parseDefaultDef(def, refs);
    case "ZodBranded" /* ZodBranded */:
      return parseBrandedDef(def, refs);
    case "ZodReadonly" /* ZodReadonly */:
      return parseReadonlyDef(def, refs);
    case "ZodCatch" /* ZodCatch */:
      return parseCatchDef(def, refs);
    case "ZodPipeline" /* ZodPipeline */:
      return parsePipelineDef(def, refs);
    case "ZodFunction" /* ZodFunction */:
    case "ZodVoid" /* ZodVoid */:
    case "ZodSymbol" /* ZodSymbol */:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  Object.assign(jsonSchema, { [zuiKey]: __spreadValues(__spreadValues({}, def[zuiKey]), jsonSchema[zuiKey]) });
  return jsonSchema;
}, "addMeta");

// src/transforms/zui-to-json-schema/Options.ts
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: false,
  unionStrategy: "anyOf"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? __spreadProps(__spreadValues({}, defaultOptions), {
  name: options
}) : __spreadValues(__spreadValues({}, defaultOptions), options), "getDefaultOptions");

// src/transforms/zui-to-json-schema/Refs.ts
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return __spreadProps(__spreadValues({}, _options), {
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs");

// src/transforms/zui-to-json-schema/zodToJsonSchema.ts
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  var _a;
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a2;
      return __spreadProps(__spreadValues({}, acc), {
        [name2]: (_a2 = parseDef(
          schema2._def,
          __spreadProps(__spreadValues({}, refs), {
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          }),
          true
        )) != null ? _a2 : {}
      });
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : options == null ? void 0 : options.name;
  const main = (_a = parseDef(
    schema._def,
    name === void 0 ? refs : __spreadProps(__spreadValues({}, refs), {
      currentPath: [...refs.basePath, refs.definitionPath, name]
    }),
    false
  )) != null ? _a : {};
  const combined = name === void 0 ? definitions ? __spreadProps(__spreadValues({}, main), {
    [refs.definitionPath]: definitions
  }) : main : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: __spreadProps(__spreadValues({}, definitions), {
      [name]: main
    })
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
}, "zodToJsonSchema");

// src/transforms/zui-to-json-schema/zui-extension.ts
var zuiToJsonSchema = /* @__PURE__ */ __name((zuiType, opts = { target: "openApi3" }) => {
  const jsonSchema = zodToJsonSchema(zuiType, opts);
  if (opts.$schemaUrl === false) {
    delete jsonSchema.$schema;
  } else if (typeof opts.$schemaUrl === "string") {
    jsonSchema.$schema = opts.$schemaUrl;
  }
  return jsonSchema;
}, "zuiToJsonSchema");

// src/z/extensions.ts
var AI_MODELS = [
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-16k",
  "gpt-4",
  "gpt-4-1106-preview",
  "gpt-4-vision-preview",
  "gpt-4-0125-preview",
  "gpt-4-turbo-preview",
  "gpt-4-turbo",
  "gpt-4o",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo-1106"
];
var variableType = ZodEnum.create([
  "any",
  "string",
  "number",
  "boolean",
  "object",
  "pattern",
  "date",
  "array",
  "target",
  "time",
  "enum"
]);
var variable = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "variable", params: __spreadValues({ type: (opts == null ? void 0 : opts.type) || "any" }, opts == null ? void 0 : opts.params) }), "variable");
var conversation = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "conversation", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "conversation");
var user = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "user", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "user");
var message = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "message", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "message");
var agent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "agent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "agent");
var event = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "event", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "event");
var table = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "table", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "table");
var tablerow = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "tablerow", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "tablerow");
var intent = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "intent", params: __spreadValues({}, opts == null ? void 0 : opts.params) }), "intent");
var aimodel = /* @__PURE__ */ __name(() => ZodEnum.create(AI_MODELS).displayAs({ id: "dropdown", params: {} }), "aimodel");
var datasource = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "datasource", params: __spreadValues({}, opts) }), "datasource");
var knowledgebase = /* @__PURE__ */ __name((opts) => ZodString.create().displayAs({ id: "knowledgebase", params: __spreadValues({}, opts) }), "knowledgebase");

// src/z/z.ts
var late = {
  object: ZodObject2.lazycreate
};
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject2.create;
var strictObjectType = ZodObject2.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var refType = ZodRef.create;
var readonlyType = ZodReadonly.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var defaultType = ZodDefault.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var fromJsonSchema = ZodType.fromJsonSchema;
var fromObject = ZodType.fromObject;
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create(__spreadProps(__spreadValues({}, arg), {
    coerce: true
  })), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create(__spreadProps(__spreadValues({}, arg), { coerce: true })), "date")
};
var NEVER = INVALID;

// src/z/index.ts
var z_default = z_exports;

// src/transforms/json-schema-to-zui/parsers/parseAnyOf.ts
var parseAnyOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.anyOf.length ? schema.anyOf.length === 1 ? parseSchema(schema.anyOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "anyOf", 0]
  })) : `z.union([${schema.anyOf.map((schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "anyOf", i] }))).join(", ")}])` : `z.any()`;
}, "parseAnyOf");

// src/transforms/json-schema-to-zui/parsers/parseBoolean.ts
var parseBoolean = /* @__PURE__ */ __name((_schema) => {
  var _a;
  if ((_a = _schema[zuiKey]) == null ? void 0 : _a.coerce) {
    return "z.coerce.boolean()";
  }
  return "z.boolean()";
}, "parseBoolean");

// src/transforms/json-schema-to-zui/parsers/parseDefault.ts
var parseDefault = /* @__PURE__ */ __name((_schema) => {
  return "z.any()";
}, "parseDefault");

// src/transforms/json-schema-to-zui/parsers/parseMultipleType.ts
var parseMultipleType = /* @__PURE__ */ __name((schema, refs) => {
  return `z.union([${schema.type.map((type) => parseSchema(__spreadProps(__spreadValues({}, schema), { type }), refs)).join(", ")}])`;
}, "parseMultipleType");

// src/transforms/json-schema-to-zui/parsers/parseNot.ts
var parseNot = /* @__PURE__ */ __name((schema, refs) => {
  return `z.any().refine((value) => !${parseSchema(schema.not, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "not"]
  }))}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
}, "parseNot");

// src/transforms/json-schema-to-zui/parsers/parseNull.ts
var parseNull = /* @__PURE__ */ __name((_schema) => {
  return "z.null()";
}, "parseNull");

// src/transforms/json-schema-to-zui/utils.ts
var half = /* @__PURE__ */ __name((arr) => {
  return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
}, "half");
var omit = /* @__PURE__ */ __name((obj, ...keys2) => Object.keys(obj).reduce((acc, key) => {
  if (!keys2.includes(key)) {
    acc[key] = obj[key];
  }
  return acc;
}, {}), "omit");
function withMessage(schema, key, get2) {
  var _a;
  const value = schema[key];
  let r = "";
  if (value !== void 0) {
    const got = get2({ value, json: JSON.stringify(value) });
    if (got) {
      const opener = got[0];
      const prefix = got.length === 3 ? got[1] : "";
      const closer = got.length === 3 ? got[2] : got[1];
      r += opener;
      if (((_a = schema.errorMessage) == null ? void 0 : _a[key]) !== void 0) {
        r += prefix + JSON.stringify(schema.errorMessage[key]);
      }
      r;
      r += closer;
    }
  }
  return r;
}
__name(withMessage, "withMessage");

// src/transforms/json-schema-to-zui/parsers/parseAllOf.ts
var originalIndex = Symbol("Original index");
var ensureOriginalIndex = /* @__PURE__ */ __name((arr) => {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i];
    if (typeof item === "boolean") {
      newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
    } else if (originalIndex in item) {
      return arr;
    } else {
      newArr.push(__spreadProps(__spreadValues({}, item), { [originalIndex]: i }));
    }
  }
  return newArr;
}, "ensureOriginalIndex");
function parseAllOf(schema, refs) {
  if (schema.allOf.length === 0) {
    return "z.never()";
  } else if (schema.allOf.length === 1) {
    const item = schema.allOf[0];
    return parseSchema(item, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "allOf", item[originalIndex]]
    }));
  } else {
    const [left, right] = half(ensureOriginalIndex(schema.allOf));
    return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf(
      {
        allOf: right
      },
      refs
    )})`;
  }
}
__name(parseAllOf, "parseAllOf");

// src/transforms/json-schema-to-zui/parsers/parseArray.ts
var parseArray = /* @__PURE__ */ __name((schema, refs) => {
  if (Array.isArray(schema.items)) {
    return `z.tuple([${schema.items.map((v, i) => parseSchema(v, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "items", i] })))}])`;
  }
  let r = !schema.items ? "z.array(z.any())" : `z.array(${parseSchema(schema.items, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "items"]
  }))})`;
  r += withMessage(schema, "minItems", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxItems", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseArray");

// src/transforms/json-schema-to-zui/parsers/parseConst.ts
var parseConst = /* @__PURE__ */ __name((schema) => {
  return `z.literal(${JSON.stringify(schema.const)})`;
}, "parseConst");

// src/transforms/json-schema-to-zui/parsers/parseEnum.ts
var parseEnum = /* @__PURE__ */ __name((schema) => {
  if (schema.enum.length === 0) {
    return "z.never()";
  } else if (schema.enum.length === 1) {
    return `z.literal(${JSON.stringify(schema.enum[0])})`;
  } else if (schema.enum.every((x) => typeof x === "string")) {
    return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;
  } else {
    return `z.union([${schema.enum.map((x) => `z.literal(${JSON.stringify(x)})`).join(", ")}])`;
  }
}, "parseEnum");

// src/transforms/json-schema-to-zui/parsers/parseIfThenElse.ts
var parseIfThenElse = /* @__PURE__ */ __name((schema, refs) => {
  const $if = parseSchema(schema.if, __spreadProps(__spreadValues({}, refs), { path: [...refs.path, "if"] }));
  const $then = parseSchema(schema.then, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "then"]
  }));
  const $else = parseSchema(schema.else, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "else"]
  }));
  return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse");

// src/transforms/json-schema-to-zui/parsers/parseNumber.ts
var parseNumber = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.number()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    r = "z.coerce.number()";
  }
  if (schema.type === "integer") {
    r += withMessage(schema, "type", () => [".int(", ")"]);
  } else {
    r += withMessage(schema, "format", ({ value }) => {
      if (value === "int64") {
        return [".int(", ")"];
      }
    });
  }
  r += withMessage(schema, "multipleOf", ({ value, json }) => {
    if (value === 1) {
      if (r.startsWith("z.number().int(")) {
        return;
      }
      return [".int(", ")"];
    }
    return [`.multipleOf(${json}`, ", ", ")"];
  });
  if (typeof schema.minimum === "number") {
    if (schema.exclusiveMinimum === true) {
      r += withMessage(schema, "minimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "minimum", ({ json }) => [`.gte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMinimum === "number") {
    r += withMessage(schema, "exclusiveMinimum", ({ json }) => [`.gt(${json}`, ", ", ")"]);
  }
  if (typeof schema.maximum === "number") {
    if (schema.exclusiveMaximum === true) {
      r += withMessage(schema, "maximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
    } else {
      r += withMessage(schema, "maximum", ({ json }) => [`.lte(${json}`, ", ", ")"]);
    }
  } else if (typeof schema.exclusiveMaximum === "number") {
    r += withMessage(schema, "exclusiveMaximum", ({ json }) => [`.lt(${json}`, ", ", ")"]);
  }
  return r;
}, "parseNumber");

// src/transforms/json-schema-to-zui/parsers/parseOneOf.ts
var parseOneOf = /* @__PURE__ */ __name((schema, refs) => {
  return schema.oneOf.length ? schema.oneOf.length === 1 ? parseSchema(schema.oneOf[0], __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "oneOf", 0]
  })) : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  ).join(", ")}];
    const errors = schemas.reduce(
      (errors: z.ZodError[], schema) =>
        ((result) => ("error" in result ? [...errors, result.error] : errors))(
          schema.safeParse(x)
        ),
      []
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()";
}, "parseOneOf");

// src/transforms/json-schema-to-zui/parsers/parseObject.ts
function parseObject(objectSchema, refs) {
  let properties = void 0;
  if (objectSchema.properties) {
    if (!Object.keys(objectSchema.properties).length) {
      properties = "z.object({})";
    } else {
      properties = "z.object({ ";
      properties += Object.keys(objectSchema.properties).map((key) => {
        const propSchema = objectSchema.properties[key];
        const result = `${JSON.stringify(key)}: ${parseSchema(propSchema, __spreadProps(__spreadValues({}, refs), {
          path: [...refs.path, "properties", key]
        }))}`;
        const hasDefault = typeof propSchema === "object" && propSchema.default !== void 0 || typeof objectSchema.default === "object" && objectSchema.default !== null && key in objectSchema.default;
        const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : typeof propSchema === "object" && propSchema.required === true;
        const optional = !hasDefault && !required;
        return optional ? `${result}.optional()` : result;
      }).join(", ");
      properties += " })";
    }
  }
  const additionalProperties = objectSchema.additionalProperties !== void 0 ? parseSchema(objectSchema.additionalProperties, __spreadProps(__spreadValues({}, refs), {
    path: [...refs.path, "additionalProperties"]
  })) : void 0;
  let patternProperties = void 0;
  if (objectSchema.patternProperties) {
    const parsedPatternProperties = Object.fromEntries(
      Object.entries(objectSchema.patternProperties).map(([key, value]) => {
        return [
          key,
          parseSchema(value, __spreadProps(__spreadValues({}, refs), {
            path: [...refs.path, "patternProperties", key]
          }))
        ];
      }, {})
    );
    patternProperties = "";
    if (properties) {
      if (additionalProperties) {
        patternProperties += `.catchall(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
      }
    } else {
      if (additionalProperties) {
        patternProperties += `z.record(z.union([${[
          ...Object.values(parsedPatternProperties),
          additionalProperties
        ].join(", ")}]))`;
      } else if (Object.keys(parsedPatternProperties).length > 1) {
        patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
      } else {
        patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
      }
    }
    patternProperties += ".superRefine((value, ctx) => {\n";
    patternProperties += "for (const key in value) {\n";
    if (additionalProperties) {
      if (objectSchema.properties) {
        patternProperties += `let evaluated = [${Object.keys(objectSchema.properties).map((key) => JSON.stringify(key)).join(", ")}].includes(key)
`;
      } else {
        patternProperties += `let evaluated = false
`;
      }
    }
    for (const key in objectSchema.patternProperties) {
      patternProperties += "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
      if (additionalProperties) {
        patternProperties += "evaluated = true\n";
      }
      patternProperties += "const result = " + parsedPatternProperties[key] + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    if (additionalProperties) {
      patternProperties += "if (!evaluated) {\n";
      patternProperties += "const result = " + additionalProperties + ".safeParse(value[key])\n";
      patternProperties += "if (!result.success) {\n";
      patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`;
      patternProperties += "}\n";
      patternProperties += "}\n";
    }
    patternProperties += "}\n";
    patternProperties += "})";
  }
  let output4 = properties ? patternProperties ? properties + patternProperties : additionalProperties ? additionalProperties === "z.never()" ? properties + ".strict()" : properties + `.catchall(${additionalProperties})` : properties : patternProperties ? patternProperties : additionalProperties ? `z.record(${additionalProperties})` : "z.record(z.any())";
  if (its.an.anyOf(objectSchema)) {
    output4 += `.and(${parseAnyOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        anyOf: objectSchema.anyOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.a.oneOf(objectSchema)) {
    output4 += `.and(${parseOneOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        oneOf: objectSchema.oneOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  if (its.an.allOf(objectSchema)) {
    output4 += `.and(${parseAllOf(
      __spreadProps(__spreadValues({}, objectSchema), {
        allOf: objectSchema.allOf.map(
          (x) => typeof x === "object" && !x.type && (x.properties || x.additionalProperties || x.patternProperties) ? __spreadProps(__spreadValues({}, x), { type: "object" }) : x
        )
      }),
      refs
    )})`;
  }
  return output4;
}
__name(parseObject, "parseObject");

// src/transforms/json-schema-to-zui/parsers/parseString.ts
var parseString = /* @__PURE__ */ __name((schema) => {
  var _a;
  let r = "z.string()";
  if ((_a = schema[zuiKey]) == null ? void 0 : _a.coerce) {
    if (schema.format === "date-time") {
      return "z.coerce.date()";
    }
    r = "z.coerce.string()";
  }
  r += withMessage(schema, "format", ({ value }) => {
    switch (value) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime(", ")"];
    }
  });
  r += withMessage(schema, "pattern", ({ json }) => [`.regex(new RegExp(${json})`, ", ", ")"]);
  r += withMessage(schema, "minLength", ({ json }) => [`.min(${json}`, ", ", ")"]);
  r += withMessage(schema, "maxLength", ({ json }) => [`.max(${json}`, ", ", ")"]);
  return r;
}, "parseString");

// src/transforms/json-schema-to-zui/parsers/parseNullable.ts
var parseNullable = /* @__PURE__ */ __name((schema, refs) => {
  return `${parseSchema(omit(schema, "nullable"), refs, true)}.nullable()`;
}, "parseNullable");

// src/transforms/json-schema-to-zui/parsers/parseRef.ts
var parseRef = /* @__PURE__ */ __name((schema) => {
  return `z.ref('${schema.$ref}')`;
}, "parseRef");

// src/transforms/json-schema-to-zui/parsers/parseDiscriminator.ts
var parseDiscriminator = /* @__PURE__ */ __name((schema, refs) => {
  var _a, _b;
  if (schema.oneOf.length <= 1 || !((_a = schema.discriminator) == null ? void 0 : _a.propertyName)) {
    return parseOneOf(schema, refs);
  }
  const schemas = schema.oneOf.map(
    (schema2, i) => parseSchema(schema2, __spreadProps(__spreadValues({}, refs), {
      path: [...refs.path, "oneOf", i]
    }))
  );
  return `z.discriminatedUnion("${(_b = schema.discriminator) == null ? void 0 : _b.propertyName}", [${schemas.join(", ")}])`;
}, "parseDiscriminator");

// src/transforms/json-schema-to-zui/parsers/parseSchema.ts
var parseSchema = /* @__PURE__ */ __name((schema, refs = { seen: /* @__PURE__ */ new Map(), path: [] }, blockMeta) => {
  if (typeof schema !== "object") return schema ? "z.any()" : "z.never()";
  if (refs.parserOverride) {
    const custom2 = refs.parserOverride(schema, refs);
    if (typeof custom2 === "string") {
      return custom2;
    }
  }
  let seen = refs.seen.get(schema);
  if (seen) {
    if (seen.r !== void 0) {
      return seen.r;
    }
    if (refs.depth === void 0 || seen.n >= refs.depth) {
      return "z.any()";
    }
    seen.n += 1;
  } else {
    seen = { r: void 0, n: 0 };
    refs.seen.set(schema, seen);
  }
  let parsed = selectParser2(schema, refs);
  if (!blockMeta) {
    parsed = addMeta2(schema, parsed);
    if (!refs.withoutDefaults) {
      parsed = addDefaults(schema, parsed);
    }
  }
  seen.r = parsed;
  return parsed;
}, "parseSchema");
var addMeta2 = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
}, "addMeta");
var addDefaults = /* @__PURE__ */ __name((schema, parsed) => {
  if (schema.default !== void 0) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
}, "addDefaults");
var selectParser2 = /* @__PURE__ */ __name((schema, refs) => {
  if (its.a.nullable(schema)) {
    return parseNullable(schema, refs);
  } else if (its.an.object(schema)) {
    return parseObject(schema, refs);
  } else if (its.an.array(schema)) {
    return parseArray(schema, refs);
  } else if (its.an.anyOf(schema)) {
    return parseAnyOf(schema, refs);
  } else if (its.an.allOf(schema)) {
    return parseAllOf(schema, refs);
  } else if (its.a.discriminator(schema)) {
    return parseDiscriminator(schema, refs);
  } else if (its.a.oneOf(schema)) {
    return parseOneOf(schema, refs);
  } else if (its.a.not(schema)) {
    return parseNot(schema, refs);
  } else if (its.an.enum(schema)) {
    return parseEnum(schema);
  } else if (its.a.const(schema)) {
    return parseConst(schema);
  } else if (its.a.multipleType(schema)) {
    return parseMultipleType(schema, refs);
  } else if (its.a.primitive(schema, "string")) {
    return parseString(schema);
  } else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) {
    return parseNumber(schema);
  } else if (its.a.primitive(schema, "boolean")) {
    return parseBoolean(schema);
  } else if (its.a.primitive(schema, "null")) {
    return parseNull(schema);
  } else if (its.a.conditional(schema)) {
    return parseIfThenElse(schema, refs);
  } else if (its.a.ref(schema)) {
    return parseRef(schema);
  } else {
    return parseDefault(schema);
  }
}, "selectParser");
var its = {
  an: {
    object: /* @__PURE__ */ __name((x) => x.type === "object", "object"),
    array: /* @__PURE__ */ __name((x) => x.type === "array", "array"),
    anyOf: /* @__PURE__ */ __name((x) => x.anyOf !== void 0, "anyOf"),
    allOf: /* @__PURE__ */ __name((x) => x.allOf !== void 0, "allOf"),
    enum: /* @__PURE__ */ __name((x) => x.enum !== void 0, "enum")
  },
  a: {
    nullable: /* @__PURE__ */ __name((x) => x.nullable === true, "nullable"),
    multipleType: /* @__PURE__ */ __name((x) => Array.isArray(x.type), "multipleType"),
    not: /* @__PURE__ */ __name((x) => x.not !== void 0, "not"),
    const: /* @__PURE__ */ __name((x) => x.const !== void 0, "const"),
    primitive: /* @__PURE__ */ __name((x, p) => x.type === p, "primitive"),
    conditional: /* @__PURE__ */ __name((x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else), "conditional"),
    discriminator: /* @__PURE__ */ __name((x) => {
      var _a;
      return x.oneOf !== void 0 && ((_a = x.discriminator) == null ? void 0 : _a.propertyName) !== void 0;
    }, "discriminator"),
    oneOf: /* @__PURE__ */ __name((x) => x.oneOf !== void 0, "oneOf"),
    ref: /* @__PURE__ */ __name((x) => x.$ref !== void 0, "ref")
  }
};

// src/transforms/common/eval-zui-string.ts
var evalZuiString = /* @__PURE__ */ __name((zuiString) => {
  let result;
  try {
    result = new Function("z", `return ${zuiString}`)(z_default);
  } catch (thrown) {
    const err = thrown instanceof Error ? thrown : new Error(String(thrown));
    return { sucess: false, error: `Failed to evaluate schema: ${err.message}` };
  }
  if (!(result instanceof z_default.ZodType)) {
    return { sucess: false, error: `String "${zuiString}" does not evaluate to a Zod schema` };
  }
  return {
    sucess: true,
    value: result
  };
}, "evalZuiString");

// src/transforms/json-schema-to-zui/index.ts
var jsonSchemaToZodStr = /* @__PURE__ */ __name((schema) => {
  return parseSchema(schema, {
    seen: /* @__PURE__ */ new Map(),
    path: []
  });
}, "jsonSchemaToZodStr");
var jsonSchemaToZod = /* @__PURE__ */ __name((schema) => {
  let code = jsonSchemaToZodStr(schema);
  code = code.replaceAll("errors: z.ZodError[]", "errors");
  const evaluationResult = evalZuiString(code);
  if (!evaluationResult.sucess) {
    throw new JsonSchemaToZuiError(evaluationResult.error);
  }
  return evaluationResult.value;
}, "jsonSchemaToZod");
var applyZuiPropsRecursively = /* @__PURE__ */ __name((zodField, jsonSchemaField) => {
  var _a, _b;
  if (jsonSchemaField[zuiKey] && zodField._def) {
    zodField._def[zuiKey] = jsonSchemaField[zuiKey];
  }
  if (((_a = zodField._def) == null ? void 0 : _a.typeName) === "ZodObject" && jsonSchemaField.type === "object" && jsonSchemaField.properties) {
    Object.entries(jsonSchemaField.properties).forEach(([key, nestedField]) => {
      const shape = typeof zodField._def.shape === "function" ? zodField._def.shape() : zodField._def.shape;
      if (shape[key]) {
        applyZuiPropsRecursively(shape[key], nestedField);
      }
    });
  }
  if (((_b = zodField._def) == null ? void 0 : _b.typeName) === "ZodRecord" && jsonSchemaField.type === "object" && jsonSchemaField.additionalProperties) {
    applyZuiPropsRecursively(zodField._def.valueType, jsonSchemaField.additionalProperties);
  }
  if (jsonSchemaField.type === "array" && jsonSchemaField.items) {
    const items = jsonSchemaField.items;
    if (typeof items === "object" && !Array.isArray(items)) {
      const arrayShape = zodField._def.type;
      if (arrayShape) {
        applyZuiPropsRecursively(arrayShape, items);
      }
    } else if (Array.isArray(items)) {
      items.forEach((item, index) => {
        const def = zodField._def;
        if (def.typeName === z_exports.ZodFirstPartyTypeKind.ZodTuple) {
          applyZuiPropsRecursively(def.items[index], item);
        }
      });
    }
  }
}, "applyZuiPropsRecursively");
var jsonSchemaToZui = /* @__PURE__ */ __name((schema) => {
  const zodSchema = jsonSchemaToZod(schema);
  applyZuiPropsRecursively(zodSchema, schema);
  return zodSchema;
}, "jsonSchemaToZui");

// src/ui/Form.tsx
import React4, { useState as useState2, useEffect as useEffect3 } from "react";

// src/ui/ErrorBoundary.tsx
import React2, { Component } from "react";
var _ErrorBoundary = class _ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    this.state = {
      hasError: false,
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }
  render() {
    if (this.state.hasError && this.props.fallback) {
      return /* @__PURE__ */ React2.createElement(this.props.fallback, { error: this.state.error, schema: this.props.fieldSchema });
    }
    return this.props.children;
  }
};
__name(_ErrorBoundary, "ErrorBoundary");
var ErrorBoundary = _ErrorBoundary;
function withErrorBoundary(Component2, fallback) {
  return (props) => /* @__PURE__ */ React2.createElement(ErrorBoundary, { fallback, fieldSchema: props.fieldSchema, path: props.path }, /* @__PURE__ */ React2.createElement(Component2, __spreadValues({}, props)));
}
__name(withErrorBoundary, "withErrorBoundary");

// src/ui/ElementRenderer.tsx
import React3, { useMemo as useMemo3 } from "react";
var FormElementRenderer = /* @__PURE__ */ __name((_a) => {
  var _b = _a, {
    components,
    fieldSchema,
    path,
    required,
    fallback
  } = _b, childProps = __objRest(_b, [
    "components",
    "fieldSchema",
    "path",
    "required",
    "fallback"
  ]);
  var _a2, _b2;
  const { formData, disabled, hidden, handlePropertyChange, addArrayItem, removeArrayItem, formErrors, formValid } = useFormData(fieldSchema, path);
  const data = useMemo3(() => getPathData(formData, path), [formData, path]);
  const componentMeta = useMemo3(() => resolveComponent(components, fieldSchema), [fieldSchema, components]);
  const { discriminator, discriminatedSchema, discriminatorValue } = useDiscriminator(fieldSchema, path);
  if (!componentMeta) {
    return null;
  }
  if (hidden === true) {
    return null;
  }
  const { Component: _component, type } = componentMeta;
  const baseProps = {
    type,
    componentID: componentMeta.id,
    scope: path.join("."),
    context: {
      path,
      readonly: false,
      formData,
      formErrors,
      formValid,
      updateForm: handlePropertyChange,
      updateFormData: /* @__PURE__ */ __name((data2) => handlePropertyChange([], data2), "updateFormData")
    },
    onChange: /* @__PURE__ */ __name((data2) => handlePropertyChange(path, data2), "onChange"),
    disabled,
    errors: (formErrors == null ? void 0 : formErrors.filter((e) => e.path === path)) || [],
    label: ((_a2 = fieldSchema[zuiKey]) == null ? void 0 : _a2.title) || formatTitle(((_b2 = path[path.length - 1]) == null ? void 0 : _b2.toString()) || ""),
    params: componentMeta.params,
    schema: fieldSchema,
    zuiProps: fieldSchema[zuiKey]
  };
  if (fieldSchema.type === "array" && type === "array") {
    const Component3 = _component;
    const schema = baseProps.schema;
    const dataArray = Array.isArray(data) ? data : typeof data === "object" ? data : [];
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema,
      data: dataArray,
      addItem: /* @__PURE__ */ __name((data2) => addArrayItem(path, data2), "addItem"),
      removeItem: /* @__PURE__ */ __name((index) => removeArrayItem(path, index), "removeItem")
    }), childProps);
    if (Array.isArray(fieldSchema.items)) {
      return null;
    }
    return /* @__PURE__ */ React3.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), Array.isArray(props2.data) ? props2.data.map((_, index) => {
      const childPath = [...path, index.toString()];
      return /* @__PURE__ */ React3.createElement(
        ErrorBoundary,
        {
          key: childPath.join("."),
          fallback,
          fieldSchema: fieldSchema.items,
          path: childPath
        },
        /* @__PURE__ */ React3.createElement(
          FormElementRenderer,
          {
            key: childPath.join("."),
            components,
            fieldSchema: fieldSchema.items,
            path: childPath,
            required,
            isArrayChild: true,
            index,
            removeSelf: () => removeArrayItem(path, index),
            fallback
          }
        )
      );
    }) : []);
  }
  if (fieldSchema.type === "object" && type === "object" && fieldSchema.properties) {
    const Component3 = _component;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema: baseProps.schema,
      data: data || {}
    }), childProps);
    return /* @__PURE__ */ React3.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), Object.entries(fieldSchema.properties).map(([fieldName, childSchema]) => {
      var _a3;
      const childPath = [...path, fieldName];
      return /* @__PURE__ */ React3.createElement(ErrorBoundary, { key: childPath.join("."), fallback, fieldSchema: childSchema, path: childPath }, /* @__PURE__ */ React3.createElement(
        FormElementRenderer,
        {
          key: childPath.join("."),
          components,
          fieldSchema: childSchema,
          path: childPath,
          required: ((_a3 = fieldSchema.required) == null ? void 0 : _a3.includes(fieldName)) || false,
          isArrayChild: false,
          fallback
        }
      ));
    }));
  }
  if (type === "discriminatedUnion") {
    const Component3 = _component;
    const props2 = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
      type,
      schema: baseProps.schema,
      data: data || {},
      discriminatorKey: (discriminator == null ? void 0 : discriminator.key) || null,
      discriminatorLabel: formatTitle((discriminator == null ? void 0 : discriminator.key) || "Unknown"),
      discriminatorOptions: (discriminator == null ? void 0 : discriminator.values) || null,
      discriminatorValue,
      setDiscriminator: /* @__PURE__ */ __name((disc) => {
        if (!(discriminator == null ? void 0 : discriminator.key)) {
          console.warn("No discriminator key found, cannot set discriminator");
          return;
        }
        handlePropertyChange(path, { [discriminator.key]: disc });
      }, "setDiscriminator")
    }), childProps);
    return /* @__PURE__ */ React3.createElement(Component3, __spreadProps(__spreadValues({ key: baseProps.scope }, props2), { isArrayChild: props2.isArrayChild }), discriminatedSchema && /* @__PURE__ */ React3.createElement(ErrorBoundary, { key: path.join("."), fallback, fieldSchema: discriminatedSchema, path }, /* @__PURE__ */ React3.createElement(
      FormElementRenderer,
      {
        components,
        fieldSchema: discriminatedSchema,
        path,
        required,
        isArrayChild: false,
        fallback
      }
    )));
  }
  const Component2 = _component;
  const props = __spreadValues(__spreadProps(__spreadValues({}, baseProps), {
    type,
    schema: baseProps.schema,
    config: {},
    required,
    data,
    description: fieldSchema.description
  }), childProps);
  return /* @__PURE__ */ React3.createElement(Component2, __spreadValues({}, props));
}, "FormElementRenderer");

// src/ui/Form.tsx
var ZuiForm = /* @__PURE__ */ __name(({
  schema,
  components,
  onChange,
  value,
  disableValidation,
  fallback,
  dataTransform,
  onValidation
}) => {
  const [formData, setFormData] = useState2(value);
  useEffect3(() => {
    onChange(formData);
  }, [formData]);
  useEffect3(() => {
    const defaults = getDefaultValues(schema);
    setFormData((prev) => deepMerge(defaults, prev));
  }, [JSON.stringify(schema), setFormData]);
  return /* @__PURE__ */ React4.createElement(
    FormDataProvider,
    {
      formData,
      setFormData,
      formSchema: schema,
      disableValidation: disableValidation || false,
      dataTransform,
      onValidation
    },
    /* @__PURE__ */ React4.createElement(ErrorBoundary, { fallback, fieldSchema: schema, path: [] }, /* @__PURE__ */ React4.createElement(
      FormElementRenderer,
      {
        components,
        fieldSchema: schema,
        path: [],
        fallback,
        required: true,
        isArrayChild: false
      }
    ))
  );
}, "ZuiForm");

// src/ui/component-definitions.ts
var defaultComponentDefinitions = {
  string: {},
  number: {
    slider: {
      id: "slider",
      params: z_default.object({})
    }
  },
  boolean: {
    switch: {
      id: "switch",
      params: z_default.object({})
    }
  },
  array: {},
  object: {},
  discriminatedUnion: {}
};

// src/index.ts
var transforms = {
  errors: errors_exports,
  jsonSchemaToZui,
  zuiToJsonSchema,
  objectToZui,
  toTypescript,
  toTypescriptSchema
};
export {
  BRAND,
  DIRTY,
  EMPTY_PATH,
  ErrorBoundary,
  INVALID,
  NEVER,
  OK,
  ParseInputLazyPath,
  ParseStatus,
  ZodType as Schema,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  ZodFirstPartyTypeKind,
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject2 as ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodRef,
  ZodType as ZodSchema,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodEffects as ZodTransformer,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  ZuiForm,
  addIssueToContext,
  agent,
  aimodel,
  anyType as any,
  arrayType as array,
  bigIntType as bigint,
  booleanType as boolean,
  coerce,
  conversation,
  createZodEnum,
  cuid2Regex,
  cuidRegex,
  custom,
  datasource,
  dateType as date,
  datetimeRegex,
  defaultComponentDefinitions,
  discriminatedUnionType as discriminatedUnion,
  effectsType as effect,
  emailRegex,
  enumType as enum,
  errorUtil,
  event,
  fromJsonSchema,
  fromObject,
  functionType as function,
  getErrorMap,
  getParsedType,
  instanceOfType as instanceof,
  intent,
  intersectionType as intersection,
  ipv4Regex,
  ipv6Regex,
  isAborted,
  isArraySchema,
  isAsync,
  isDirty,
  isEmojiRegex,
  isObjectSchema,
  isValid,
  jsonSchemaToZui,
  knowledgebase,
  late,
  lazyType as lazy,
  literalType as literal,
  makeIssue,
  mapType as map,
  message,
  nanType as nan,
  nativeEnumType as nativeEnum,
  neverType as never,
  nullType as null,
  nullableType as nullable,
  numberType as number,
  objectType as object,
  objectToZui,
  objectUtil,
  oboolean,
  onumber,
  optionalType as optional,
  ostring,
  pipelineType as pipeline,
  preprocessType as preprocess,
  processCreateParams,
  promiseType as promise,
  quotelessJson,
  readonlyType as readonly,
  recordType as record,
  refType as ref,
  setType as set,
  setErrorMap,
  strictObjectType as strictObject,
  stringType as string,
  symbolType as symbol,
  table,
  tablerow,
  effectsType as transformer,
  transforms,
  tupleType as tuple,
  ulidRegex,
  undefinedType as undefined,
  unionType as union,
  unknownType as unknown,
  user,
  util,
  uuidRegex,
  variable,
  voidType as void,
  withErrorBoundary,
  z_exports as z,
  zuiToJsonSchema
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=index.js.map