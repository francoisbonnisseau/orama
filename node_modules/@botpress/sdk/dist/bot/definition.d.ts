import { Table } from '@botpress/client';
import { IntegrationPackage, PluginPackage } from '../package';
import { PluginInterfaceExtension } from '../plugin';
import { SchemaDefinition } from '../schema';
import { ValueOf, Merge } from '../utils/type-utils';
import z, { ZuiObjectSchema } from '../zui';
type BaseConfig = ZuiObjectSchema;
type BaseStates = Record<string, ZuiObjectSchema>;
type BaseEvents = Record<string, ZuiObjectSchema>;
type BaseActions = Record<string, ZuiObjectSchema>;
type BaseTables = Record<string, ZuiObjectSchema>;
type BaseWorkflows = Record<string, ZuiObjectSchema>;
export type TagDefinition = {
    title?: string;
    description?: string;
};
export type StateType = 'conversation' | 'user' | 'bot';
export type StateDefinition<TState extends BaseStates[string] = BaseStates[string]> = SchemaDefinition<TState> & {
    type: StateType;
    expiry?: number;
};
export type RecurringEventDefinition<TEvents extends BaseEvents = BaseEvents> = {
    [K in keyof TEvents]: {
        type: K;
        payload: z.infer<TEvents[K]>;
        schedule: {
            cron: string;
        };
    };
}[keyof TEvents];
export type EventDefinition<TEvent extends BaseEvents[string] = BaseEvents[string]> = SchemaDefinition<TEvent>;
export type ConfigurationDefinition<TConfig extends BaseConfig = BaseConfig> = SchemaDefinition<TConfig>;
export type UserDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type ConversationDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type MessageDefinition = {
    tags?: Record<string, TagDefinition>;
};
export type ActionDefinition<TAction extends BaseActions[string] = BaseActions[string]> = {
    title?: string;
    description?: string;
    input: SchemaDefinition<TAction>;
    output: SchemaDefinition<ZuiObjectSchema>;
};
export type WorkflowDefinition<TWorkflow extends BaseWorkflows[string] = BaseWorkflows[string]> = {
    title?: string;
    description?: string;
    input: SchemaDefinition<TWorkflow>;
    output: SchemaDefinition<ZuiObjectSchema>;
    tags?: Record<string, TagDefinition>;
};
export type TableDefinition<TTable extends BaseTables[string] = BaseTables[string]> = Merge<Omit<Table, 'id' | 'createdAt' | 'updatedAt' | 'name'>, {
    schema: TTable;
}>;
export type IntegrationConfigInstance<I extends IntegrationPackage = IntegrationPackage> = {
    enabled: boolean;
} & ({
    configurationType?: null;
    configuration: z.infer<NonNullable<I['definition']['configuration']>['schema']>;
} | ValueOf<{
    [K in keyof NonNullable<I['definition']['configurations']>]: {
        configurationType: K;
        configuration: z.infer<NonNullable<I['definition']['configurations']>[K]['schema']>;
    };
}>);
export type PluginConfigInstance<P extends PluginPackage = PluginPackage> = {
    alias?: string;
    configuration: z.infer<NonNullable<P['definition']['configuration']>['schema']>;
    interfaces: {
        [I in keyof NonNullable<P['definition']['interfaces']>]: PluginInterfaceExtension;
    };
};
export type IntegrationInstance = IntegrationPackage & IntegrationConfigInstance;
export type PluginInstance = PluginPackage & PluginConfigInstance;
export type BotDefinitionProps<TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions, TTables extends BaseTables = BaseTables, TWorkflows extends BaseWorkflows = BaseWorkflows> = {
    integrations?: {
        [K: string]: IntegrationInstance;
    };
    plugins?: {
        [K: string]: PluginInstance;
    };
    user?: UserDefinition;
    conversation?: ConversationDefinition;
    message?: MessageDefinition;
    states?: {
        [K in keyof TStates]: StateDefinition<TStates[K]>;
    };
    configuration?: ConfigurationDefinition;
    events?: {
        [K in keyof TEvents]: EventDefinition<TEvents[K]>;
    };
    recurringEvents?: Record<string, RecurringEventDefinition<TEvents>>;
    actions?: {
        [K in keyof TActions]: ActionDefinition<TActions[K]>;
    };
    tables?: {
        [K in keyof TTables]: TableDefinition<TTables[K]>;
    };
    /**
     * # EXPERIMENTAL
     * This API is experimental and may change in the future.
     */
    workflows?: {
        [K in keyof TWorkflows]: WorkflowDefinition<TWorkflows[K]>;
    };
};
export declare class BotDefinition<TStates extends BaseStates = BaseStates, TEvents extends BaseEvents = BaseEvents, TActions extends BaseActions = BaseActions, TTables extends BaseTables = BaseTables, TWorkflows extends BaseWorkflows = BaseWorkflows> {
    readonly props: BotDefinitionProps<TStates, TEvents, TActions, TTables, TWorkflows>;
    readonly integrations: this['props']['integrations'];
    readonly plugins: this['props']['plugins'];
    readonly user: this['props']['user'];
    readonly conversation: this['props']['conversation'];
    readonly message: this['props']['message'];
    readonly states: this['props']['states'];
    readonly configuration: this['props']['configuration'];
    readonly events: this['props']['events'];
    readonly recurringEvents: this['props']['recurringEvents'];
    readonly actions: this['props']['actions'];
    readonly tables: this['props']['tables'];
    readonly workflows: this['props']['workflows'];
    constructor(props: BotDefinitionProps<TStates, TEvents, TActions, TTables, TWorkflows>);
    addIntegration<I extends IntegrationPackage>(integrationPkg: I, config: IntegrationConfigInstance<I>): this;
    addPlugin<P extends PluginPackage>(pluginPkg: P, config: PluginConfigInstance<P>): this;
    private _mergeUser;
    private _mergeConversation;
    private _mergeMessage;
    private _mergeStates;
    private _mergeEvents;
    private _mergeRecurringEvents;
    private _mergeActions;
    private _mergeTables;
    private _mergeWorkflows;
    private _prefixKeys;
}
export {};
